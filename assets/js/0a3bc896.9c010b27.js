"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[653],{8453(e,n,r){r.d(n,{R:()=>a,x:()=>s});var i=r(6540);const t={},o=i.createContext(t);function a(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(o.Provider,{value:n},e.children)}},9624(e,n,r){r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>g,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"guides/error-handling","title":"Error Handling","description":"achievements-engine provides comprehensive error handling with type-safe error classes and recovery strategies.","source":"@site/docs/guides/error-handling.md","sourceDirName":"guides","slug":"/guides/error-handling","permalink":"/achievements-engine/docs/guides/error-handling","draft":false,"unlisted":false,"editUrl":"https://github.com/dave-b-b/achievements-engine/tree/main/docs/docs/guides/error-handling.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Event-Based Tracking","permalink":"/achievements-engine/docs/guides/event-based-tracking"},"next":{"title":"Data Portability","permalink":"/achievements-engine/docs/guides/data-portability"}}');var t=r(4848),o=r(8453);const a={sidebar_position:3},s="Error Handling",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Error Event Handling",id:"error-event-handling",level:2},{value:"Error Types",id:"error-types",level:2},{value:"StorageError",id:"storageerror",level:3},{value:"ConfigurationError",id:"configurationerror",level:3},{value:"Metric Validation",id:"metric-validation",level:3},{value:"Error Handling Patterns",id:"error-handling-patterns",level:2},{value:"Basic Error Handling",id:"basic-error-handling",level:3},{value:"Advanced Error Handling",id:"advanced-error-handling",level:3},{value:"Retry Logic",id:"retry-logic",level:3},{value:"Graceful Degradation",id:"graceful-degradation",level:2},{value:"Storage Failure",id:"storage-failure",level:3},{value:"Configuration Errors",id:"configuration-errors",level:3},{value:"Network Failures (REST API)",id:"network-failures-rest-api",level:3},{value:"Type Guards",id:"type-guards",level:2},{value:"Error Properties",id:"error-properties",level:2},{value:"StorageError",id:"storageerror-1",level:3},{value:"ConfigurationError",id:"configurationerror-1",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Always Handle Error Events",id:"1-always-handle-error-events",level:3},{value:"2. Log Errors to Monitoring Service",id:"2-log-errors-to-monitoring-service",level:3},{value:"3. Implement Storage Fallback",id:"3-implement-storage-fallback",level:3},{value:"4. Validate Configuration Early",id:"4-validate-configuration-early",level:3},{value:"Debugging",id:"debugging",level:2},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:3},{value:"&quot;LocalStorage quota exceeded&quot;",id:"localstorage-quota-exceeded",level:4},{value:"&quot;Achievement not unlocking&quot;",id:"achievement-not-unlocking",level:4},{value:"&quot;Storage sync failures&quot;",id:"storage-sync-failures",level:4},{value:"Error Recovery Strategies",id:"error-recovery-strategies",level:2},{value:"Strategy 1: Automatic Retry",id:"strategy-1-automatic-retry",level:3},{value:"Strategy 2: Fallback Chain",id:"strategy-2-fallback-chain",level:3},{value:"Strategy 3: Error Queue",id:"strategy-3-error-queue",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"error-handling",children:"Error Handling"})}),"\n",(0,t.jsx)(n.p,{children:"achievements-engine provides comprehensive error handling with type-safe error classes and recovery strategies."}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"The library handles errors gracefully with:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type-safe error classes"})," for different failure modes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Error events"})," for centralized error handling"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Graceful degradation"})," - achievements continue working even if storage fails"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Recovery guidance"})," in error messages"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"error-event-handling",children:"Error Event Handling"}),"\n",(0,t.jsx)(n.p,{children:"Handle all achievement-related errors using the error event:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { AchievementEngine } from 'achievements-engine';\n\nconst engine = new AchievementEngine({\n  achievements,\n  storage: 'localStorage'\n});\n\nengine.on('error', (event) => {\n  console.error('Achievement error:', event.error.message);\n\n  // Send to error tracking service\n  if (typeof Sentry !== 'undefined') {\n    Sentry.captureException(event.error);\n  }\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Error Event Properties:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"{\n  type: 'error',\n  error: Error,           // The error instance\n  context?: string,       // Context where error occurred (e.g., 'storage', 'validation')\n  timestamp: Date\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"error-types",children:"Error Types"}),"\n",(0,t.jsx)(n.h3,{id:"storageerror",children:"StorageError"}),"\n",(0,t.jsx)(n.p,{children:"Thrown when storage operations fail (localStorage full, IndexedDB unavailable, etc.)."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { StorageError } from 'achievements-engine';\n\nengine.on('error', (event) => {\n  if (event.error instanceof StorageError) {\n    console.error('Storage failed:', event.error.message);\n    console.log('Recovery:', event.error.recoveryHint);\n  }\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Common Causes:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"localStorage quota exceeded"}),"\n",(0,t.jsx)(n.li,{children:"IndexedDB not available"}),"\n",(0,t.jsx)(n.li,{children:"Network failure (REST API storage)"}),"\n",(0,t.jsx)(n.li,{children:"Permission denied"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Recovery Hints:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'"Clear old data or switch to IndexedDB for more capacity"\n"Check browser settings - IndexedDB may be disabled"\n"Check network connection and retry"\n'})}),"\n",(0,t.jsx)(n.h3,{id:"configurationerror",children:"ConfigurationError"}),"\n",(0,t.jsx)(n.p,{children:"Thrown when achievement configuration is invalid."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// \u274c Invalid configuration\nconst achievements = {\n  score: {\n    100: { /* missing title */ }\n  }\n};\n\n// Error: ConfigurationError\n// Message: "Achievement title is required"\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Common Causes:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Missing required fields (title, icon)"}),"\n",(0,t.jsx)(n.li,{children:"Invalid threshold values"}),"\n",(0,t.jsx)(n.li,{children:"Duplicate achievement IDs"}),"\n",(0,t.jsx)(n.li,{children:"Invalid condition functions"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"metric-validation",children:"Metric Validation"}),"\n",(0,t.jsx)(n.p,{children:"Achievement metrics are validated when updated. Invalid values may be ignored or cause errors depending on the storage implementation."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"engine.update({ score: 'invalid' });  // Should be a number\n\n// May log warning or throw error depending on configuration\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Common Validation Issues:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Wrong metric type (string instead of number)"}),"\n",(0,t.jsx)(n.li,{children:"NaN or Infinity values"}),"\n",(0,t.jsx)(n.li,{children:"Null/undefined values when not expected"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"error-handling-patterns",children:"Error Handling Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"basic-error-handling",children:"Basic Error Handling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { AchievementEngine } from 'achievements-engine';\n\nconst engine = new AchievementEngine({\n  achievements,\n  storage: 'localStorage'\n});\n\nlet lastError: Error | null = null;\n\nengine.on('error', (event) => {\n  lastError = event.error;\n  console.error('Achievement error:', event.error.message);\n});\n\n// Update metrics with error handling\ntry {\n  engine.update({ score: 100 });\n} catch (error) {\n  console.error('Failed to update achievement:', error);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"advanced-error-handling",children:"Advanced Error Handling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import {\n  AchievementEngine,\n  StorageError,\n  ConfigurationError,\n  isAchievementError\n} from 'achievements-engine';\n\nfunction handleAchievementError(error: Error) {\n  if (error instanceof StorageError) {\n    // Storage failure - try fallback\n    console.warn('Storage failed, using memory storage');\n    return { action: 'switch_storage', storage: 'memory' };\n  }\n\n  if (error instanceof ConfigurationError) {\n    // Configuration error - fix and reload\n    console.error('Invalid configuration:', error.message);\n    return { action: 'fix_config' };\n  }\n\n  if (isAchievementError(error)) {\n    // Other achievement-related error\n    console.warn('Achievement error:', error.message);\n    return { action: 'log_error' };\n  }\n\n  // Unknown error\n  console.error('Unknown achievement error:', error);\n  return { action: 'report' };\n}\n\nengine.on('error', (event) => {\n  const recovery = handleAchievementError(event.error);\n  console.log('Recovery action:', recovery.action);\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"retry-logic",children:"Retry Logic"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"async function updateWithRetry(\n  engine: AchievementEngine,\n  metrics: Record<string, any>,\n  maxRetries = 3\n) {\n  let attempt = 0;\n\n  while (attempt < maxRetries) {\n    try {\n      engine.update(metrics);\n      return { success: true };\n    } catch (error) {\n      attempt++;\n\n      if (error instanceof StorageError && attempt < maxRetries) {\n        // Wait and retry\n        await new Promise(resolve => setTimeout(resolve, 1000 * attempt));\n        continue;\n      }\n\n      // Max retries reached or non-retryable error\n      return { success: false, error };\n    }\n  }\n}\n\n// Usage\nupdateWithRetry(engine, { score: 100 }).then(result => {\n    if (!result.success) {\n        console.error('Update failed after retries:', result.error);\n    }\n});\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"graceful-degradation",children:"Graceful Degradation"}),"\n",(0,t.jsx)(n.p,{children:"achievements-engine is designed to degrade gracefully when errors occur:"}),"\n",(0,t.jsx)(n.h3,{id:"storage-failure",children:"Storage Failure"}),"\n",(0,t.jsx)(n.p,{children:"When storage fails, achievements continue to work in memory:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const engine = new AchievementEngine({\n  achievements,\n  storage: 'localStorage'\n});\n\nengine.on('error', (event) => {\n  if (event.error instanceof StorageError) {\n    console.warn('Storage failed, falling back to memory storage');\n    // Achievements continue to work in memory\n    // Data will be lost on page refresh\n  }\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"configuration-errors",children:"Configuration Errors"}),"\n",(0,t.jsx)(n.p,{children:"Invalid achievements are skipped, valid ones still work:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const achievements = {\n  score: {\n    100: { title: 'Century', icon: '\ud83c\udfc6' },  // \u2705 Valid\n    500: { /* missing title */ }             // \u274c Skipped\n  }\n};\n\n// Only the valid achievement (100) will be tracked\nconst engine = new AchievementEngine({ achievements, storage: 'memory' });\n"})}),"\n",(0,t.jsx)(n.h3,{id:"network-failures-rest-api",children:"Network Failures (REST API)"}),"\n",(0,t.jsx)(n.p,{children:"Offline queue automatically stores updates locally:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const engine = new AchievementEngine({\n  achievements,\n  storage: 'restApi',\n  restApiConfig: {\n    baseUrl: 'https://api.example.com/achievements',\n    headers: {\n      'Authorization': 'Bearer YOUR_TOKEN'\n    }\n  }\n});\n\nengine.on('error', (event) => {\n  if (event.error instanceof StorageError && event.context === 'storage') {\n    console.error('API sync failed:', event.error.message);\n    // Updates are queued locally and will retry\n  }\n});\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"type-guards",children:"Type Guards"}),"\n",(0,t.jsx)(n.p,{children:"Use type guards to safely check error types:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import {\n  StorageError,\n  ConfigurationError,\n  isAchievementError\n} from 'achievements-engine';\n\nfunction handleError(error: unknown) {\n  if (error instanceof StorageError) {\n    console.log('Storage error:', error.recoveryHint);\n  } else if (error instanceof ConfigurationError) {\n    console.log('Config error:', error.message);\n  } else if (isAchievementError(error)) {\n    console.log('Achievement error:', error.message);\n  }\n}\n\nengine.on('error', (event) => {\n  handleError(event.error);\n});\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"error-properties",children:"Error Properties"}),"\n",(0,t.jsx)(n.h3,{id:"storageerror-1",children:"StorageError"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"{\n  name: 'StorageError',\n  message: 'Failed to save to localStorage',\n  recoveryHint: 'Clear old data or switch to IndexedDB',\n  originalError: DOMException,  // The underlying error\n  storageType: 'localStorage'\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"configurationerror-1",children:"ConfigurationError"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"{\n  name: 'ConfigurationError',\n  message: 'Achievement title is required',\n  achievementId: 'score_100',\n  field: 'title'\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"1-always-handle-error-events",children:"1. Always Handle Error Events"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good: Centralized error handling\nconst engine = new AchievementEngine({\n  achievements,\n  storage: 'localStorage'\n});\n\nengine.on('error', (event) => {\n  logToService(event.error);\n  showUserNotification(event.error.message);\n});\n\n// \u274c Bad: No error handling\nconst engine = new AchievementEngine({\n  achievements,\n  storage: 'localStorage'\n});\n// No error listener registered\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-log-errors-to-monitoring-service",children:"2. Log Errors to Monitoring Service"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"engine.on('error', (event) => {\n  const error = event.error;\n\n  // Send to Sentry, LogRocket, etc.\n  if (typeof Sentry !== 'undefined') {\n    Sentry.captureException(error, {\n      tags: {\n        component: 'achievements',\n        storage: error.storageType,\n        context: event.context\n      },\n      extra: {\n        recoveryHint: error.recoveryHint,\n        timestamp: event.timestamp\n      }\n    });\n  }\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-implement-storage-fallback",children:"3. Implement Storage Fallback"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function createEngineWithFallback(achievements: AchievementConfig) {\n  let storage: 'localStorage' | 'memory' = 'localStorage';\n\n  const engine = new AchievementEngine({\n    achievements,\n    storage\n  });\n\n  engine.on('error', (event) => {\n    if (event.error instanceof StorageError && storage === 'localStorage') {\n      console.warn('localStorage failed, switching to memory storage');\n      storage = 'memory';\n\n      // Recreate engine with memory storage\n      return createEngineWithFallback(achievements);\n    }\n  });\n\n  return engine;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-validate-configuration-early",children:"4. Validate Configuration Early"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { AchievementBuilder } from 'achievements-engine';\n\n// Use the builder to ensure valid configuration\nconst achievements = AchievementBuilder.combine([\n  AchievementBuilder.createScoreAchievements([100, 500, 1000]),\n  AchievementBuilder.createLevelAchievements([5, 10, 20])\n]);\n\n// Configuration is guaranteed to be valid\nconst engine = new AchievementEngine({\n  achievements,\n  storage: 'localStorage'\n});\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"debugging",children:"Debugging"}),"\n",(0,t.jsx)(n.h3,{id:"common-issues-and-solutions",children:"Common Issues and Solutions"}),"\n",(0,t.jsx)(n.h4,{id:"localstorage-quota-exceeded",children:'"LocalStorage quota exceeded"'}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Solution:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Switch to IndexedDB (50MB+ capacity)\nconst engine = new AchievementEngine({\n  achievements,\n  storage: 'indexedDB'\n});\n"})}),"\n",(0,t.jsx)(n.h4,{id:"achievement-not-unlocking",children:'"Achievement not unlocking"'}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Check:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Condition function is correct"}),"\n",(0,t.jsx)(n.li,{children:"Metric value is correct type"}),"\n",(0,t.jsx)(n.li,{children:"Achievement ID is unique"}),"\n",(0,t.jsx)(n.li,{children:"No configuration errors"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"storage-sync-failures",children:'"Storage sync failures"'}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Check:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Network connectivity"}),"\n",(0,t.jsx)(n.li,{children:"API endpoint is correct"}),"\n",(0,t.jsx)(n.li,{children:"Authentication headers are valid"}),"\n",(0,t.jsx)(n.li,{children:"CORS is configured on server"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const engine = new AchievementEngine({\n  achievements,\n  storage: 'restApi',\n  restApiConfig: {\n    baseUrl: 'https://api.example.com/achievements',\n    headers: {\n      'Authorization': `Bearer ${token}`,\n      'Content-Type': 'application/json'\n    }\n  }\n});\n\nengine.on('error', (event) => {\n  if (event.error instanceof StorageError) {\n    console.error('Storage error details:', {\n      message: event.error.message,\n      recoveryHint: event.error.recoveryHint,\n      originalError: event.error.originalError\n    });\n  }\n});\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"error-recovery-strategies",children:"Error Recovery Strategies"}),"\n",(0,t.jsx)(n.h3,{id:"strategy-1-automatic-retry",children:"Strategy 1: Automatic Retry"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"class AchievementEngineWithRetry {\n  private engine: AchievementEngine;\n  private maxRetries = 3;\n\n  constructor(config: AchievementEngineConfig) {\n    this.engine = new AchievementEngine(config);\n    this.setupErrorHandling();\n  }\n\n  private setupErrorHandling() {\n    this.engine.on('error', async (event) => {\n      if (event.error instanceof StorageError) {\n        await this.retryLastOperation();\n      }\n    });\n  }\n\n  private async retryLastOperation() {\n    // Implement retry logic\n    console.log('Retrying failed operation...');\n  }\n\n  update(metrics: Record<string, any>) {\n    return this.engine.update(metrics);\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"strategy-2-fallback-chain",children:"Strategy 2: Fallback Chain"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const storageChain = ['indexedDB', 'localStorage', 'memory'] as const;\n\nasync function createEngineWithFallback(\n  achievements: AchievementConfig,\n  storageOptions = [...storageChain]\n): Promise<AchievementEngine> {\n  if (storageOptions.length === 0) {\n    throw new Error('All storage options failed');\n  }\n\n  const storage = storageOptions[0];\n\n  try {\n    const engine = new AchievementEngine({\n      achievements,\n      storage\n    });\n\n    // Test storage\n    engine.update({});\n\n    return engine;\n  } catch (error) {\n    console.warn(`Storage ${storage} failed, trying next option...`);\n    return createEngineWithFallback(achievements, storageOptions.slice(1));\n  }\n}\n\n// Usage\nconst engine = await createEngineWithFallback(achievements);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"strategy-3-error-queue",children:"Strategy 3: Error Queue"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"class ErrorQueue {\n  private errors: Array<{ error: Error; timestamp: Date; context?: string }> = [];\n  private maxSize = 100;\n\n  add(error: Error, context?: string) {\n    this.errors.push({ error, timestamp: new Date(), context });\n\n    if (this.errors.length > this.maxSize) {\n      this.errors.shift();\n    }\n  }\n\n  getRecent(count = 10) {\n    return this.errors.slice(-count);\n  }\n\n  hasRepeatedErrors(errorType: string, threshold = 3) {\n    const recent = this.getRecent(5);\n    const count = recent.filter(e => e.error.name === errorType).length;\n    return count >= threshold;\n  }\n}\n\nconst errorQueue = new ErrorQueue();\n\nengine.on('error', (event) => {\n  errorQueue.add(event.error, event.context);\n\n  if (errorQueue.hasRepeatedErrors('StorageError', 3)) {\n    console.error('Repeated storage errors detected, switching to fallback');\n    // Implement fallback logic\n  }\n});\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/guides/data-portability",children:"Data Portability"})," - Export/import for error recovery"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/guides/storage",children:"Storage"})," - Configure different storage backends"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/guides/event-based-tracking",children:"Event-Based Tracking"})," - Listen to achievement events"]}),"\n"]})]})}function g(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);