"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[489],{8397(e,n,r){r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"guides/storage","title":"Storage Options","description":"achievements-engine supports multiple storage backends to fit different use cases, from simple in-memory storage to cloud-synchronized REST APIs.","source":"@site/docs/guides/storage.md","sourceDirName":"guides","slug":"/guides/storage","permalink":"/achievements-engine/docs/guides/storage","draft":false,"unlisted":false,"editUrl":"https://github.com/dave-b-b/achievements-engine/tree/main/docs/docs/guides/storage.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Data Portability","permalink":"/achievements-engine/docs/guides/data-portability"}}');var t=r(4848),i=r(8453);const a={sidebar_position:5},o="Storage Options",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Memory Storage",id:"memory-storage",level:2},{value:"When to Use",id:"when-to-use",level:3},{value:"Configuration",id:"configuration",level:3},{value:"Characteristics",id:"characteristics",level:3},{value:"LocalStorage",id:"localstorage",level:2},{value:"When to Use",id:"when-to-use-1",level:3},{value:"Configuration",id:"configuration-1",level:3},{value:"Features",id:"features",level:3},{value:"Characteristics",id:"characteristics-1",level:3},{value:"Best Practices",id:"best-practices",level:3},{value:"IndexedDB Storage",id:"indexeddb-storage",level:2},{value:"When to Use",id:"when-to-use-2",level:3},{value:"Configuration",id:"configuration-2",level:3},{value:"Features",id:"features-1",level:3},{value:"Characteristics",id:"characteristics-2",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"REST API Storage",id:"rest-api-storage",level:2},{value:"When to Use",id:"when-to-use-3",level:3},{value:"Configuration",id:"configuration-3",level:3},{value:"API Endpoints",id:"api-endpoints",level:3},{value:"Error Handling",id:"error-handling-1",level:3},{value:"Characteristics",id:"characteristics-3",level:3},{value:"Best Practices",id:"best-practices-1",level:3},{value:"Offline Queue Storage",id:"offline-queue-storage",level:2},{value:"When to Use",id:"when-to-use-4",level:3},{value:"Configuration",id:"configuration-4",level:3},{value:"How It Works",id:"how-it-works",level:3},{value:"Monitoring Queue Status",id:"monitoring-queue-status",level:3},{value:"Characteristics",id:"characteristics-4",level:3},{value:"Custom Storage Adapter",id:"custom-storage-adapter",level:2},{value:"Creating a Custom Adapter",id:"creating-a-custom-adapter",level:3},{value:"Async Storage Example",id:"async-storage-example",level:3},{value:"Storage Comparison",id:"storage-comparison",level:2},{value:"Performance",id:"performance",level:3},{value:"Use Case Matrix",id:"use-case-matrix",level:3},{value:"Migration Between Storage Types",id:"migration-between-storage-types",level:2},{value:"Exporting Data Before Migration",id:"exporting-data-before-migration",level:3},{value:"Storage Fallback Chain",id:"storage-fallback-chain",level:3},{value:"Best Practices",id:"best-practices-2",level:2},{value:"1. Choose the Right Storage",id:"1-choose-the-right-storage",level:3},{value:"2. Handle Storage Errors",id:"2-handle-storage-errors",level:3},{value:"3. Monitor Storage Usage",id:"3-monitor-storage-usage",level:3},{value:"4. Clear Old Data",id:"4-clear-old-data",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"storage-options",children:"Storage Options"})}),"\n",(0,t.jsx)(n.p,{children:"achievements-engine supports multiple storage backends to fit different use cases, from simple in-memory storage to cloud-synchronized REST APIs."}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"Choose the storage backend that fits your needs:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Storage"}),(0,t.jsx)(n.th,{children:"Persistence"}),(0,t.jsx)(n.th,{children:"Capacity"}),(0,t.jsx)(n.th,{children:"Use Case"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Memory"})}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Unlimited"}),(0,t.jsx)(n.td,{children:"Development, testing, temporary sessions"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"LocalStorage"})}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"~5-10MB"}),(0,t.jsx)(n.td,{children:"Small datasets, simple persistence"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"IndexedDB"})}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"~50MB+"}),(0,t.jsx)(n.td,{children:"Large datasets, complex queries"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"REST API"})}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Unlimited"}),(0,t.jsx)(n.td,{children:"Cloud sync, multi-device"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Offline Queue"})}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Unlimited"}),(0,t.jsx)(n.td,{children:"REST API with offline support"})]})]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"memory-storage",children:"Memory Storage"}),"\n",(0,t.jsx)(n.p,{children:"Simple in-memory storage. Data is lost when the page refreshes."}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use",children:"When to Use"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Development and testing"}),"\n",(0,t.jsx)(n.li,{children:"Temporary sessions"}),"\n",(0,t.jsx)(n.li,{children:"Server-side rendering (SSR)"}),"\n",(0,t.jsx)(n.li,{children:"Environments without localStorage"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"configuration",children:"Configuration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { AchievementEngine } from 'achievements-engine';\n\nconst engine = new AchievementEngine({\n  achievements,\n  storage: 'memory'\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"characteristics",children:"Characteristics"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Persistence:"})," None (data lost on refresh)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Capacity:"})," Unlimited (limited by device RAM)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance:"})," Fastest (no I/O operations)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Browser Support:"})," All environments"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"localstorage",children:"LocalStorage"}),"\n",(0,t.jsx)(n.p,{children:"Browser localStorage with automatic serialization and quota handling."}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use-1",children:"When to Use"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Web applications requiring persistence"}),"\n",(0,t.jsx)(n.li,{children:"Small to medium datasets (under 5MB)"}),"\n",(0,t.jsx)(n.li,{children:"Simple key-value storage needs"}),"\n",(0,t.jsx)(n.li,{children:"No complex queries required"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"configuration-1",children:"Configuration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const engine = new AchievementEngine({\n  achievements,\n  storage: 'localStorage'\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"features",children:"Features"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Date Serialization:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// LocalStorage automatically handles Date objects\nengine.update({ lastLogin: new Date() });\n\n// Dates are properly serialized and deserialized\nconst metrics = engine.getMetrics();\nconsole.log(metrics.lastLogin instanceof Date); // true\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Quota Error Handling:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { StorageQuotaError } from 'achievements-engine';\n\nengine.on('error', (event) => {\n  if (event.error instanceof StorageQuotaError) {\n    console.error('Storage full!');\n    console.log('Bytes needed:', event.error.bytesNeeded);\n\n    // Fallback to IndexedDB\n    // or clear old data\n  }\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"characteristics-1",children:"Characteristics"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Persistence:"})," Yes (survives page refresh)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Capacity:"})," ~5-10MB (browser dependent)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance:"})," Fast (synchronous API)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Browser Support:"})," All modern browsers"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Monitor storage usage\nfunction checkStorageSize() {\n  const data = localStorage.getItem('achievements');\n  const sizeInBytes = new Blob([data || '']).size;\n  const sizeInKB = (sizeInBytes / 1024).toFixed(2);\n  console.log(`Storage size: ${sizeInKB} KB`);\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"indexeddb-storage",children:"IndexedDB Storage"}),"\n",(0,t.jsx)(n.p,{children:"Browser IndexedDB for large datasets with better capacity."}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use-2",children:"When to Use"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Large achievement datasets"}),"\n",(0,t.jsx)(n.li,{children:"Need for complex queries"}),"\n",(0,t.jsx)(n.li,{children:"LocalStorage quota exceeded"}),"\n",(0,t.jsx)(n.li,{children:"Better performance for large data"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"configuration-2",children:"Configuration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const engine = new AchievementEngine({\n  achievements,\n  storage: 'indexedDB'\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"features-1",children:"Features"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Async Operations:"}),"\nThe ",(0,t.jsx)(n.code,{children:"AchievementEngine"})," will automatically handle the asynchronous nature of IndexedDB. The engine will be ready to use after the constructor returns."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// IndexedDB operations are asynchronous\nconst engine = new AchievementEngine({\n  achievements,\n  storage: 'indexedDB'\n});\n\n// The engine is ready to use immediately\nengine.update({ score: 100 });\n"})}),"\n",(0,t.jsx)(n.h3,{id:"characteristics-2",children:"Characteristics"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Persistence:"})," Yes (survives page refresh)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Capacity:"})," ~50MB to several GB (browser dependent)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance:"})," Fast for large datasets"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Browser Support:"})," All modern browsers, IE 10+"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"engine.on('error', (event) => {\n  if (event.error.message.includes('IndexedDB')) {\n    console.error('IndexedDB not available');\n    // Fallback to localStorage\n  }\n});\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"rest-api-storage",children:"REST API Storage"}),"\n",(0,t.jsx)(n.p,{children:"Sync achievements with a backend server for cloud storage and multi-device support."}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use-3",children:"When to Use"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Cloud-based achievement tracking"}),"\n",(0,t.jsx)(n.li,{children:"Multi-device synchronization"}),"\n",(0,t.jsx)(n.li,{children:"User accounts and profiles"}),"\n",(0,t.jsx)(n.li,{children:"Analytics and leaderboards"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"configuration-3",children:"Configuration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const engine = new AchievementEngine({\n  achievements,\n  storage: 'restApi',\n  restApiConfig: {\n    baseUrl: 'https://api.example.com',\n    userId: 'user123',\n    headers: {\n      'Authorization': `Bearer ${userToken}`,\n      'X-App-Version': '1.0.0'\n    },\n    timeout: 10000 // 10 seconds (default)\n  }\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"api-endpoints",children:"API Endpoints"}),"\n",(0,t.jsx)(n.p,{children:"Your backend should implement these endpoints:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"GET Metrics:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'GET /users/{userId}/achievements/metrics\nResponse: { "metrics": { "score": [100, 200], "level": [5] } }\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"PUT Metrics:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'PUT /users/{userId}/achievements/metrics\nBody: { "metrics": { "score": [100, 200], "level": [5] } }\nResponse: 200 OK\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"GET Unlocked Achievements:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'GET /users/{userId}/achievements/unlocked\nResponse: { "unlocked": ["score_100", "level_5"] }\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"PUT Unlocked Achievements:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'PUT /users/{userId}/achievements/unlocked\nBody: { "unlocked": ["score_100", "level_5"] }\nResponse: 200 OK\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"DELETE All Data:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"DELETE /users/{userId}/achievements\nResponse: 200 OK\n"})}),"\n",(0,t.jsx)(n.h3,{id:"error-handling-1",children:"Error Handling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { StorageError, SyncError } from 'achievements-engine';\n\nengine.on('error', (event) => {\n  if (event.error instanceof SyncError) {\n    console.error('API sync failed:', event.error.message);\n\n    // Check error details\n    if (event.error.statusCode === 401) {\n      console.log('Authentication failed - refresh token');\n    } else if (event.error.statusCode === 429) {\n      console.log('Rate limited - retry later');\n    }\n  }\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"characteristics-3",children:"Characteristics"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Persistence:"})," Yes (cloud-based)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Capacity:"})," Unlimited (server-dependent)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance:"})," Slower (network latency)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Browser Support:"})," All environments with fetch API"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"best-practices-1",children:"Best Practices"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"1. Authentication:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Refresh token before it expires\nasync function refreshToken() {\n  const newToken = await fetchNewToken();\n\n  // Update engine config\n  engine.storage.config.headers['Authorization'] = `Bearer ${newToken}`;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"2. Error Recovery:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Retry on network failures\nlet retryCount = 0;\nconst maxRetries = 3;\n\nengine.on('error', async (event) => {\n  if (event.error instanceof SyncError && retryCount < maxRetries) {\n    retryCount++;\n    console.log(`Retrying (${retryCount}/${maxRetries})...`);\n\n    await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));\n    // Retry the update\n  }\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"3. Optimistic Updates:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Update UI immediately, sync in background\nfunction updateScore(newScore: number) {\n  // Update local state immediately\n  engine.update({ score: newScore });\n\n  // API sync happens automatically in background\n  // If it fails, error event will fire\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"offline-queue-storage",children:"Offline Queue Storage"}),"\n",(0,t.jsx)(n.p,{children:"Wrapper around REST API storage that queues operations when offline and syncs when back online."}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use-4",children:"When to Use"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"REST API with unreliable network"}),"\n",(0,t.jsx)(n.li,{children:"Mobile applications"}),"\n",(0,t.jsx)(n.li,{children:"Progressive Web Apps (PWAs)"}),"\n",(0,t.jsx)(n.li,{children:"Offline-first applications"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"configuration-4",children:"Configuration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { AchievementEngine, RestApiStorage, OfflineQueueStorage } from 'achievements-engine';\n\n// Create REST API storage\nconst restStorage = new RestApiStorage({\n  baseUrl: 'https://api.example.com',\n  userId: 'user123',\n  headers: {\n    'Authorization': `Bearer ${token}`\n  }\n});\n\n// Wrap with offline queue\nconst offlineStorage = new OfflineQueueStorage(restStorage);\n\nconst engine = new AchievementEngine({\n  achievements,\n  storage: offlineStorage // Use the wrapped storage\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Online:"})," Operations are sent directly to the API"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Offline:"})," Operations are queued in localStorage"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Back Online:"})," Queue is automatically processed in order"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// User goes offline\nengine.update({ score: 100 }); // Queued locally\n\n// User scores more points while offline\nengine.update({ score: 200 }); // Queued locally\n\n// User comes back online\n// Queue automatically processes: score:100, then score:200\n"})}),"\n",(0,t.jsx)(n.h3,{id:"monitoring-queue-status",children:"Monitoring Queue Status"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Check queue length\nif (offlineStorage.queue.length > 0) {\n  console.log(`${offlineStorage.queue.length} operations queued`);\n}\n\n// Listen for sync events\nofflineStorage.on('sync:start', () => {\n  console.log('Starting sync...');\n});\n\nofflineStorage.on('sync:complete', () => {\n  console.log('Sync complete!');\n});\n\nofflineStorage.on('sync:error', (error) => {\n  console.error('Sync failed:', error);\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"characteristics-4",children:"Characteristics"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Persistence:"})," Yes (cloud + local queue)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Capacity:"})," Unlimited (server + localStorage for queue)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance:"})," Fast locally, syncs in background"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Browser Support:"})," Browsers with online/offline events"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"custom-storage-adapter",children:"Custom Storage Adapter"}),"\n",(0,t.jsx)(n.p,{children:"Implement your own storage backend for special requirements."}),"\n",(0,t.jsx)(n.h3,{id:"creating-a-custom-adapter",children:"Creating a Custom Adapter"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { AchievementStorage, AchievementMetrics } from 'achievements-engine';\n\nclass CustomStorage implements AchievementStorage {\n  private data: {\n    metrics: AchievementMetrics;\n    unlocked: string[];\n  } = {\n    metrics: {},\n    unlocked: []\n  };\n\n  getMetrics(): AchievementMetrics {\n    return this.data.metrics;\n  }\n\n  setMetrics(metrics: AchievementMetrics): void {\n    this.data.metrics = metrics;\n    // Your custom persistence logic\n    this.saveToDisk(metrics);\n  }\n\n  getUnlockedAchievements(): string[] {\n    return this.data.unlocked;\n  }\n\n  setUnlockedAchievements(achievements: string[]): void {\n    this.data.unlocked = achievements;\n    // Your custom persistence logic\n    this.saveToDisk(achievements);\n  }\n\n  clear(): void {\n    this.data = { metrics: {}, unlocked: [] };\n    // Your custom clear logic\n    this.clearDisk();\n  }\n\n  private saveToDisk(data: any) {\n    // Implement your persistence\n  }\n\n  private clearDisk() {\n    // Implement your clear logic\n  }\n}\n\n// Use custom storage\nconst engine = new AchievementEngine({\n  achievements,\n  storage: new CustomStorage()\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"async-storage-example",children:"Async Storage Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { AsyncAchievementStorage, AchievementMetrics } from 'achievements-engine';\n\nclass AsyncCustomStorage implements AsyncAchievementStorage {\n  async getMetrics(): Promise<AchievementMetrics> {\n    const data = await fetch('/api/metrics');\n    return data.json();\n  }\n\n  async setMetrics(metrics: AchievementMetrics): Promise<void> {\n    await fetch('/api/metrics', {\n      method: 'PUT',\n      body: JSON.stringify(metrics)\n    });\n  }\n\n  async getUnlockedAchievements(): Promise<string[]> {\n    const data = await fetch('/api/unlocked');\n    return data.json();\n  }\n\n  async setUnlockedAchievements(achievements: string[]): Promise<void> {\n    await fetch('/api/unlocked', {\n      method: 'PUT',\n      body: JSON.stringify(achievements)\n    });\n  }\n\n  async clear(): Promise<void> {\n    await fetch('/api/clear', { method: 'DELETE' });\n  }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"storage-comparison",children:"Storage Comparison"}),"\n",(0,t.jsx)(n.h3,{id:"performance",children:"Performance"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Storage"}),(0,t.jsx)(n.th,{children:"Read"}),(0,t.jsx)(n.th,{children:"Write"}),(0,t.jsx)(n.th,{children:"Capacity"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Memory"}),(0,t.jsx)(n.td,{children:"Fastest"}),(0,t.jsx)(n.td,{children:"Fastest"}),(0,t.jsx)(n.td,{children:"RAM-limited"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"LocalStorage"}),(0,t.jsx)(n.td,{children:"Fast"}),(0,t.jsx)(n.td,{children:"Fast"}),(0,t.jsx)(n.td,{children:"~5-10MB"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"IndexedDB"}),(0,t.jsx)(n.td,{children:"Fast"}),(0,t.jsx)(n.td,{children:"Medium"}),(0,t.jsx)(n.td,{children:"~50MB+"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"REST API"}),(0,t.jsx)(n.td,{children:"Slow"}),(0,t.jsx)(n.td,{children:"Slow"}),(0,t.jsx)(n.td,{children:"Unlimited"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Offline Queue"}),(0,t.jsx)(n.td,{children:"Fast*"}),(0,t.jsx)(n.td,{children:"Fast*"}),(0,t.jsx)(n.td,{children:"Unlimited"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"*Fast locally, syncs in background"}),"\n",(0,t.jsx)(n.h3,{id:"use-case-matrix",children:"Use Case Matrix"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Small web app, no account system\nstorage: 'localStorage'\n\n// Large dataset, no backend\nstorage: 'indexedDB'\n\n// User accounts, cloud sync required\nstorage: 'restApi'\n\n// Mobile app, unreliable network\nstorage: new OfflineQueueStorage(restApiStorage)\n\n// Server-side rendering\nstorage: 'memory'\n\n// React Native app\n// See simple-api.md for AsyncStorageAdapter example\nstorage: new AsyncStorageAdapter()\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"migration-between-storage-types",children:"Migration Between Storage Types"}),"\n",(0,t.jsx)(n.h3,{id:"exporting-data-before-migration",children:"Exporting Data Before Migration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Export from current storage\nconst oldEngine = new AchievementEngine({\n  achievements,\n  storage: 'localStorage'\n});\n\nconst exportedData = oldEngine.export();\n\n// Create new engine with different storage\nconst newEngine = new AchievementEngine({\n  achievements,\n  storage: 'indexedDB'\n});\n\n// Import data to new storage\nnewEngine.import(exportedData);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"storage-fallback-chain",children:"Storage Fallback Chain"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"async function createEngineWithFallback(achievements: any) {\n  const storageOptions = ['indexedDB', 'localStorage', 'memory'];\n\n  for (const storage of storageOptions) {\n    try {\n      const engine = new AchievementEngine({\n        achievements,\n        storage: storage as any\n      });\n\n      // Test the storage by doing a write/read operation\n      engine.update({ test: 1 });\n\n      console.log(`Using storage: ${storage}`);\n      return engine;\n    } catch (error) {\n      console.warn(`${storage} failed, trying next option`);\n    }\n  }\n\n  throw new Error('All storage options failed');\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"best-practices-2",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"1-choose-the-right-storage",children:"1. Choose the Right Storage"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// For simple web apps\nconst engine = new AchievementEngine({\n  achievements,\n  storage: 'localStorage'\n});\n\n// For apps with user accounts\nconst engine = new AchievementEngine({\n  achievements,\n  storage: 'restApi',\n  restApiConfig: { /* ... */ }\n});\n\n// For offline-capable apps\nconst engine = new AchievementEngine({\n  achievements,\n  storage: new OfflineQueueStorage(restApiStorage)\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-handle-storage-errors",children:"2. Handle Storage Errors"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { StorageError, StorageQuotaError } from 'achievements-engine';\n\nengine.on('error', (event) => {\n  if (event.error instanceof StorageQuotaError) {\n    // Storage full - clear old data or upgrade to IndexedDB\n    console.error('Storage quota exceeded');\n  } else if (event.error instanceof StorageError) {\n    // Generic storage error - fallback or retry\n    console.error('Storage failed:', event.error.message);\n  }\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-monitor-storage-usage",children:"3. Monitor Storage Usage"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Check localStorage usage\nfunction getStorageUsage() {\n  let total = 0;\n  for (let key in localStorage) {\n    if (localStorage.hasOwnProperty(key)) {\n      total += localStorage[key].length + key.length;\n    }\n  }\n  return (total / 1024).toFixed(2) + ' KB';\n}\n\nconsole.log('LocalStorage usage:', getStorageUsage());\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-clear-old-data",children:"4. Clear Old Data"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Clear achievements (useful for testing or reset)\nengine.clear();\n\n// Export before clearing (backup)\nconst backup = engine.export();\nlocalStorage.setItem('achievement_backup', backup);\n\n// Clear\nengine.clear();\n\n// Restore if needed\nconst backup = localStorage.getItem('achievement_backup');\nif (backup) {\n  engine.import(backup);\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/guides/data-portability",children:"Data Portability"})," - Export and import achievement data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/guides/error-handling",children:"Error Handling"})," - Handle storage failures gracefully"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/guides/builder-api",children:"Builder API"})," - Create achievements with the builder API"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453(e,n,r){r.d(n,{R:()=>a,x:()=>o});var s=r(6540);const t={},i=s.createContext(t);function a(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);