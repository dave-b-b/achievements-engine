"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[455],{865(e,n,t){t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"guides/data-portability","title":"Data Portability","description":"Export and import achievement data for backups, cross-device sync, and cloud storage integration.","source":"@site/docs/guides/data-portability.md","sourceDirName":"guides","slug":"/guides/data-portability","permalink":"/achievements-engine/docs/guides/data-portability","draft":false,"unlisted":false,"editUrl":"https://github.com/dave-b-b/achievements-engine/tree/main/docs/docs/guides/data-portability.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Error Handling","permalink":"/achievements-engine/docs/guides/error-handling"},"next":{"title":"Storage Options","permalink":"/achievements-engine/docs/guides/storage"}}');var s=t(4848),i=t(8453);const a={sidebar_position:4},c="Data Portability",o={},l=[{value:"Overview",id:"overview",level:2},{value:"Basic Export/Import",id:"basic-exportimport",level:2},{value:"Export Data",id:"export-data",level:3},{value:"Import Data",id:"import-data",level:3},{value:"Export API",id:"export-api",level:2},{value:"Using the Engine",id:"using-the-engine",level:3},{value:"Using the Utility Function",id:"using-the-utility-function",level:3},{value:"Creating Configuration Hash",id:"creating-configuration-hash",level:3},{value:"Import Strategies",id:"import-strategies",level:2},{value:"Replace Strategy (Default)",id:"replace-strategy-default",level:3},{value:"Merge Strategy",id:"merge-strategy",level:3},{value:"Validated Import",id:"validated-import",level:3},{value:"Import Options",id:"import-options",level:2},{value:"ImportOptions Interface",id:"importoptions-interface",level:3},{value:"ImportResult Interface",id:"importresult-interface",level:3},{value:"Backup to File",id:"backup-to-file",level:2},{value:"Download as JSON File (Browser)",id:"download-as-json-file-browser",level:3},{value:"Upload from File (Browser)",id:"upload-from-file-browser",level:3},{value:"Cloud Storage Integration",id:"cloud-storage-integration",level:2},{value:"AWS S3 Integration",id:"aws-s3-integration",level:3},{value:"Usage",id:"usage",level:3},{value:"Azure Blob Storage Integration",id:"azure-blob-storage-integration",level:3},{value:"Automatic Backup Strategies",id:"automatic-backup-strategies",level:2},{value:"Backup on Achievement Unlock",id:"backup-on-achievement-unlock",level:3},{value:"Periodic Auto-Backup",id:"periodic-auto-backup",level:3},{value:"Backup on State Changes",id:"backup-on-state-changes",level:3},{value:"Cross-Device Sync with REST API",id:"cross-device-sync-with-rest-api",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Encrypt Sensitive Data",id:"1-encrypt-sensitive-data",level:3},{value:"2. Version Your Backups",id:"2-version-your-backups",level:3},{value:"3. Validate Before Import",id:"3-validate-before-import",level:3},{value:"4. Handle Import Errors Gracefully",id:"4-handle-import-errors-gracefully",level:3},{value:"5. Implement Backup Retention",id:"5-implement-backup-retention",level:3},{value:"Complete Backup System Example",id:"complete-backup-system-example",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"data-portability",children:"Data Portability"})}),"\n",(0,s.jsx)(n.p,{children:"Export and import achievement data for backups, cross-device sync, and cloud storage integration."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"achievements-engine provides comprehensive data portability:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Export"})," achievement data as JSON"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Import"})," data with merge strategies"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cloud storage"})," integration (AWS S3, Azure Blob Storage)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cross-device sync"})," via REST API"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Backup and restore"})," functionality"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Configuration hash validation"})," to prevent version mismatches"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"basic-exportimport",children:"Basic Export/Import"}),"\n",(0,s.jsx)(n.h3,{id:"export-data",children:"Export Data"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { AchievementEngine } from 'achievements-engine';\n\nconst engine = new AchievementEngine({\n  achievements,\n  storage: 'localStorage'\n});\n\n// Export all data as JSON string\nconst jsonData = engine.export();\nconsole.log(jsonData);  // JSON string\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Exported Format:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "version": "1.1.0",\n  "configHash": "abc123def456",\n  "timestamp": 1703337000000,\n  "metrics": {\n    "score": [100, 150],\n    "level": [5],\n    "completedTutorial": [true]\n  },\n  "unlockedAchievements": ["score_100", "level_5", "tutorial_complete"]\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"import-data",children:"Import Data"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { importAchievementData } from 'achievements-engine';\n\nconst result = engine.import(jsonData);\n\nif (result.success) {\n  console.log('Import successful!');\n  console.log('Warnings:', result.warnings);\n} else {\n  console.error('Import failed:', result.errors);\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"export-api",children:"Export API"}),"\n",(0,s.jsx)(n.h3,{id:"using-the-engine",children:"Using the Engine"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Export from the engine instance\nconst data = engine.export();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"using-the-utility-function",children:"Using the Utility Function"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { exportAchievementData, createConfigHash } from 'achievements-engine';\n\nconst data = exportAchievementData({\n  metrics: engine.getMetrics(),\n  unlockedAchievements: engine.getUnlocked(),\n  achievements  // Your achievement config\n});\n\nconsole.log(data);  // JSON string\n"})}),"\n",(0,s.jsx)(n.h3,{id:"creating-configuration-hash",children:"Creating Configuration Hash"}),"\n",(0,s.jsx)(n.p,{children:"The configuration hash helps validate that imported data matches your achievement configuration:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { createConfigHash } from 'achievements-engine';\n\nconst hash = createConfigHash(achievements);\nconsole.log(hash);  // \"abc123def456\"\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"import-strategies",children:"Import Strategies"}),"\n",(0,s.jsx)(n.h3,{id:"replace-strategy-default",children:"Replace Strategy (Default)"}),"\n",(0,s.jsx)(n.p,{children:"Completely replaces existing data:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const result = engine.import(jsonData, {\n  merge: false,\n  overwrite: true\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use when:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Restoring from a known good backup"}),"\n",(0,s.jsx)(n.li,{children:"Resetting all achievements"}),"\n",(0,s.jsx)(n.li,{children:"Initial data load"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"merge-strategy",children:"Merge Strategy"}),"\n",(0,s.jsx)(n.p,{children:"Combines imported data with existing data:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const result = engine.import(jsonData, {\n  merge: true,\n  overwrite: false\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Merge rules:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Unlocked achievements stay unlocked (union)"}),"\n",(0,s.jsx)(n.li,{children:"Metrics are combined (arrays merged)"}),"\n",(0,s.jsx)(n.li,{children:"Preserves all progress from both sources"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use when:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Syncing between devices"}),"\n",(0,s.jsx)(n.li,{children:"Importing partial backups"}),"\n",(0,s.jsx)(n.li,{children:"Merging multiple saves"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"validated-import",children:"Validated Import"}),"\n",(0,s.jsx)(n.p,{children:"Validate configuration hash before importing:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const result = engine.import(jsonData, {\n  merge: true,\n  validateConfig: true,\n  expectedConfigHash: createConfigHash(achievements)\n});\n\nif (!result.success) {\n  console.error('Configuration mismatch!', result.errors);\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"import-options",children:"Import Options"}),"\n",(0,s.jsx)(n.h3,{id:"importoptions-interface",children:"ImportOptions Interface"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface ImportOptions {\n  merge?: boolean;              // Combine with existing data (default: false)\n  overwrite?: boolean;          // Overwrite existing data (default: true)\n  validateConfig?: boolean;     // Validate configuration hash (default: false)\n  expectedConfigHash?: string;  // Expected config hash for validation\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"importresult-interface",children:"ImportResult Interface"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface ImportResult {\n  success: boolean;\n  errors?: string[];\n  warnings?: string[];\n  mergedMetrics?: AchievementMetrics;\n  mergedUnlocked?: string[];\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"backup-to-file",children:"Backup to File"}),"\n",(0,s.jsx)(n.h3,{id:"download-as-json-file-browser",children:"Download as JSON File (Browser)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function downloadBackup(engine: AchievementEngine) {\n  const data = engine.export();\n  const blob = new Blob([data], { type: 'application/json' });\n  const url = URL.createObjectURL(blob);\n\n  const link = document.createElement('a');\n  link.href = url;\n  link.download = `achievements-backup-${Date.now()}.json`;\n  link.click();\n\n  URL.revokeObjectURL(url);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"upload-from-file-browser",children:"Upload from File (Browser)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function uploadBackup(engine: AchievementEngine, file: File) {\n  const reader = new FileReader();\n\n  reader.onload = async (e) => {\n    const jsonData = e.target?.result as string;\n    const result = engine.import(jsonData, { merge: true });\n\n    if (result.success) {\n      console.log('Backup restored!');\n      if (result.warnings?.length) {\n        console.warn('Import warnings:', result.warnings);\n      }\n    } else {\n      console.error('Import failed:', result.errors);\n    }\n  };\n\n  reader.readAsText(file);\n}\n\n// Usage\nconst fileInput = document.getElementById('file-input') as HTMLInputElement;\nfileInput.addEventListener('change', (e) => {\n  const file = (e.target as HTMLInputElement).files?.[0];\n  if (file) {\n    uploadBackup(engine, file);\n  }\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"cloud-storage-integration",children:"Cloud Storage Integration"}),"\n",(0,s.jsx)(n.h3,{id:"aws-s3-integration",children:"AWS S3 Integration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { S3 } from 'aws-sdk';\nimport { AchievementEngine } from 'achievements-engine';\n\nclass S3BackupService {\n  private s3: S3;\n  private bucket: string;\n\n  constructor() {\n    this.s3 = new S3({\n      accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\n      region: 'us-east-1'\n    });\n    this.bucket = 'my-achievements-backup';\n  }\n\n  async backup(engine: AchievementEngine, userId: string): Promise<{ success: boolean; location?: string; error?: any }> {\n    const data = engine.export();\n\n    const params = {\n      Bucket: this.bucket,\n      Key: `users/${userId}/achievements-${Date.now()}.json`,\n      Body: data,\n      ContentType: 'application/json',\n      ServerSideEncryption: 'AES256'  // Encrypt at rest\n    };\n\n    try {\n      const result = await this.s3.putObject(params).promise();\n      console.log('Backed up to S3');\n      return { success: true, location: result.ETag };\n    } catch (error) {\n      console.error('S3 backup failed:', error);\n      return { success: false, error };\n    }\n  }\n\n  async restore(engine: AchievementEngine, backupKey: string): Promise<ImportResult> {\n    const params = {\n      Bucket: this.bucket,\n      Key: backupKey\n    };\n\n    try {\n      const data = await this.s3.getObject(params).promise();\n      const result = engine.import(jsonData, { merge: true });\n      console.log('Restored from S3');\n      return result;\n    } catch (error) {\n      console.error('S3 restore failed:', error);\n      return { success: false, errors: [error.message] };\n    }\n  }\n\n  async listBackups(userId: string) {\n    const params = {\n      Bucket: this.bucket,\n      Prefix: `users/${userId}/`\n    };\n\n    const data = await this.s3.listObjectsV2(params).promise();\n\n    return data.Contents?.map(item => ({\n      key: item.Key,\n      size: item.Size,\n      lastModified: item.LastModified\n    })) || [];\n  }\n\n  async deleteOldBackups(userId: string, keepCount: number = 10) {\n    const backups = await this.listBackups(userId);\n\n    if (backups.length > keepCount) {\n      const toDelete = backups\n        .sort((a, b) => (b.lastModified?.getTime() || 0) - (a.lastModified?.getTime() || 0))\n        .slice(keepCount);\n\n      for (const backup of toDelete) {\n        await this.s3.deleteObject({\n          Bucket: this.bucket,\n          Key: backup.key!\n        }).promise();\n      }\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"usage",children:"Usage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const backupService = new S3BackupService();\n\n// Backup\nawait backupService.backup(engine, 'user123');\n\n// Restore\nawait backupService.restore(engine, 'users/user123/achievements-1703337000000.json');\n\n// List backups\nconst backups = await backupService.listBackups('user123');\n\n// Prune old backups\nawait backupService.deleteOldBackups('user123', 10);\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"azure-blob-storage-integration",children:"Azure Blob Storage Integration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { BlobServiceClient } from '@azure/storage-blob';\nimport { AchievementEngine } from 'achievements-engine';\n\nclass AzureBackupService {\n  private containerClient;\n\n  constructor() {\n    const connectionString = process.env.AZURE_STORAGE_CONNECTION_STRING!;\n    const blobServiceClient = BlobServiceClient.fromConnectionString(connectionString);\n    this.containerClient = blobServiceClient.getContainerClient('achievements-backup');\n  }\n\n  async backup(engine: AchievementEngine, userId: string) {\n    const data = engine.export();\n    const blobName = `users/${userId}/achievements-${Date.now()}.json`;\n    const blockBlobClient = this.containerClient.getBlockBlobClient(blobName);\n\n    try {\n      await blockBlobClient.upload(data, data.length, {\n        blobHTTPHeaders: { blobContentType: 'application/json' }\n      });\n\n      console.log('Backed up to Azure Blob Storage');\n      return { success: true, blobName };\n    } catch (error) {\n      console.error('Azure backup failed:', error);\n      return { success: false, error };\n    }\n  }\n\n  async restore(engine: AchievementEngine, blobName: string) {\n    const blockBlobClient = this.containerClient.getBlockBlobClient(blobName);\n\n    try {\n      const downloadResponse = await blockBlobClient.download(0);\n      const jsonData = await this.streamToString(downloadResponse.readableStreamBody!);\n\n      const result = engine.import(jsonData, { merge: true });\n      console.log('Restored from Azure');\n      return result;\n    } catch (error) {\n      console.error('Azure restore failed:', error);\n      return { success: false, errors: [error.message] };\n    }\n  }\n\n  private async streamToString(readableStream: NodeJS.ReadableStream): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const chunks: string[] = [];\n      readableStream.on('data', (data) => {\n        chunks.push(data.toString());\n      });\n      readableStream.on('end', () => {\n        resolve(chunks.join(''));\n      });\n      readableStream.on('error', reject);\n    });\n  }\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"automatic-backup-strategies",children:"Automatic Backup Strategies"}),"\n",(0,s.jsx)(n.h3,{id:"backup-on-achievement-unlock",children:"Backup on Achievement Unlock"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const engine = new AchievementEngine({\n  achievements,\n  storage: 'localStorage'\n});\n\nengine.on('achievement:unlocked', async (event) => {\n  // Backup to cloud whenever an achievement unlocks\n  await backupService.backup(engine, userId);\n  console.log(`Backed up after unlocking: ${event.achievementTitle}`);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"periodic-auto-backup",children:"Periodic Auto-Backup"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Backup every 5 minutes\nconst backupInterval = setInterval(async () => {\n  await backupService.backup(engine, userId);\n  console.log('Auto-backup completed');\n}, 5 * 60 * 1000);\n\n// Cleanup on app shutdown\nprocess.on('SIGINT', () => {\n  clearInterval(backupInterval);\n  process.exit();\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"backup-on-state-changes",children:"Backup on State Changes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"engine.on('state:changed', async (event) => {\n  // Backup whenever metrics or achievements change\n  await backupService.backup(engine, userId);\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"cross-device-sync-with-rest-api",children:"Cross-Device Sync with REST API"}),"\n",(0,s.jsx)(n.p,{children:"Use REST API storage for automatic cross-device synchronization:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { AchievementEngine, RestApiStorage } from 'achievements-engine';\n\nconst engine = new AchievementEngine({\n  achievements,\n  storage: 'restApi',\n  restApiConfig: {\n    baseUrl: 'https://api.example.com/achievements',\n    headers: {\n      'Authorization': `Bearer ${userToken}`,\n      'X-User-ID': userId\n    }\n  }\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"The REST API storage automatically:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Syncs on every update"}),"\n",(0,s.jsx)(n.li,{children:"Pulls latest data on initialization"}),"\n",(0,s.jsx)(n.li,{children:"Handles server-side conflict resolution"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-encrypt-sensitive-data",children:"1. Encrypt Sensitive Data"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import CryptoJS from 'crypto-js';\n\nfunction encryptData(data: string, secret: string): string {\n  return CryptoJS.AES.encrypt(data, secret).toString();\n}\n\nfunction decryptData(encryptedData: string, secret: string): string {\n  const bytes = CryptoJS.AES.decrypt(encryptedData, secret);\n  return bytes.toString(CryptoJS.enc.Utf8);\n}\n\n// Export with encryption\nconst data = engine.export();\nconst encrypted = encryptData(data, userSecret);\nawait backupService.backupEncrypted(encrypted, userId);\n\n// Import with decryption\nconst encrypted = await backupService.restoreEncrypted(backupKey);\nconst decrypted = decryptData(encrypted, userSecret);\nengine.import(decrypted);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-version-your-backups",children:"2. Version Your Backups"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const APP_VERSION = '1.1.0';\nconst blobName = `users/${userId}/v${APP_VERSION}/achievements-${Date.now()}.json`;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-validate-before-import",children:"3. Validate Before Import"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { createConfigHash } from 'achievements-engine';\n\nconst expectedHash = createConfigHash(achievements);\n\nconst result = engine.import(jsonData, {\n  merge: true,\n  validateConfig: true,\n  expectedConfigHash: expectedHash\n});\n\nif (!result.success) {\n  console.error('Configuration mismatch!', result.errors);\n  // Don't import - achievement definitions have changed\n} else {\n  console.log('Import successful with valid configuration');\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-handle-import-errors-gracefully",children:"4. Handle Import Errors Gracefully"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async function safeImport(engine: AchievementEngine, jsonData: string) {\n  try {\n    const result = engine.import(jsonData, { merge: true });\n\n    if (!result.success) {\n      console.error('Import failed:', result.errors);\n      return false;\n    }\n\n    if (result.warnings?.length) {\n      console.warn('Import warnings:', result.warnings);\n    }\n\n    console.log('Import successful');\n    return true;\n  } catch (error) {\n    console.error('Import error:', error);\n    return false;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"5-implement-backup-retention",children:"5. Implement Backup Retention"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"class BackupManager {\n  async backupWithRetention(\n    engine: AchievementEngine,\n    userId: string,\n    maxBackups: number = 10\n  ) {\n    // Create new backup\n    await backupService.backup(engine, userId);\n\n    // Prune old backups\n    await backupService.deleteOldBackups(userId, maxBackups);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"complete-backup-system-example",children:"Complete Backup System Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { AchievementEngine } from 'achievements-engine';\n\nclass AchievementBackupManager {\n  private engine: AchievementEngine;\n  private backupService: S3BackupService;\n  private userId: string;\n  private autoBackupInterval?: NodeJS.Timeout;\n\n  constructor(engine: AchievementEngine, userId: string) {\n    this.engine = engine;\n    this.backupService = new S3BackupService();\n    this.userId = userId;\n    this.setupAutoBackup();\n  }\n\n  private setupAutoBackup() {\n    // Backup on achievement unlock\n    this.engine.on('achievement:unlocked', () => this.backup());\n\n    // Periodic backup every 5 minutes\n    this.autoBackupInterval = setInterval(() => this.backup(), 5 * 60 * 1000);\n  }\n\n  async backup() {\n    try {\n      const result = await this.backupService.backup(this.engine, this.userId);\n      if (result.success) {\n        console.log('Backup successful');\n        await this.backupService.deleteOldBackups(this.userId, 10);\n      }\n    } catch (error) {\n      console.error('Backup failed:', error);\n    }\n  }\n\n  async restore(backupKey: string) {\n    try {\n      const result = await this.backupService.restore(this.engine, backupKey);\n      if (result.success) {\n        console.log('Restore successful');\n      } else {\n        console.error('Restore failed:', result.errors);\n      }\n      return result;\n    } catch (error) {\n      console.error('Restore error:', error);\n      return { success: false, errors: [error.message] };\n    }\n  }\n\n  async listBackups() {\n    return await this.backupService.listBackups(this.userId);\n  }\n\n  destroy() {\n    if (this.autoBackupInterval) {\n      clearInterval(this.autoBackupInterval);\n    }\n  }\n}\n\n// Usage\nconst backupManager = new AchievementBackupManager(engine, 'user123');\n\n// Manual backup\nawait backupManager.backup();\n\n// List available backups\nconst backups = await backupManager.listBackups();\n\n// Restore from backup\nawait backupManager.restore('users/user123/achievements-1703337000000.json');\n\n// Cleanup on shutdown\nprocess.on('SIGINT', () => {\n  backupManager.destroy();\n  process.exit();\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/guides/error-handling",children:"Error Handling"})," - Handle backup failures gracefully"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/guides/storage",children:"Storage Options"})," - Configure different storage backends"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/guides/event-based-tracking",children:"Event-Based Tracking"})," - Listen to achievement events"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>a,x:()=>c});var r=t(6540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);