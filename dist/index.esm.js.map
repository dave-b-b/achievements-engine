{"version":3,"file":"index.esm.js","sources":["../src/EventEmitter.ts","../src/utils/configNormalizer.ts","../src/utils/dataExport.ts","../src/utils/dataImport.ts","../src/types.ts","../src/errors/AchievementErrors.ts","../src/storage/LocalStorage.ts","../src/storage/MemoryStorage.ts","../node_modules/tslib/tslib.es6.js","../src/storage/IndexedDBStorage.ts","../src/storage/RestApiStorage.ts","../src/storage/AsyncStorageAdapter.ts","../src/AchievementEngine.ts","../src/storage/OfflineQueueStorage.ts"],"sourcesContent":["/**\n * Lightweight, type-safe event emitter for the achievements engine\n * Zero dependencies, memory-leak safe implementation\n */\n\nexport type EventHandler<T = any> = (data: T) => void;\nexport type UnsubscribeFn = () => void;\n\nexport class EventEmitter {\n  private listeners: Map<string, Set<EventHandler>>;\n  private onceListeners: Map<string, Set<EventHandler>>;\n\n  constructor() {\n    this.listeners = new Map();\n    this.onceListeners = new Map();\n  }\n\n  /**\n   * Subscribe to an event\n   * @param event - Event name\n   * @param handler - Event handler function\n   * @returns Unsubscribe function\n   */\n  on<T = any>(event: string, handler: EventHandler<T>): UnsubscribeFn {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n\n    this.listeners.get(event)!.add(handler as EventHandler);\n\n    // Return unsubscribe function\n    return () => this.off(event, handler);\n  }\n\n  /**\n   * Subscribe to an event once (auto-unsubscribes after first emission)\n   * @param event - Event name\n   * @param handler - Event handler function\n   * @returns Unsubscribe function\n   */\n  once<T = any>(event: string, handler: EventHandler<T>): UnsubscribeFn {\n    if (!this.onceListeners.has(event)) {\n      this.onceListeners.set(event, new Set());\n    }\n\n    this.onceListeners.get(event)!.add(handler as EventHandler);\n\n    // Return unsubscribe function\n    return () => {\n      const onceSet = this.onceListeners.get(event);\n      if (onceSet) {\n        onceSet.delete(handler as EventHandler);\n      }\n    };\n  }\n\n  /**\n   * Unsubscribe from an event\n   * @param event - Event name\n   * @param handler - Event handler function to remove\n   */\n  off<T = any>(event: string, handler: EventHandler<T>): void {\n    const regularListeners = this.listeners.get(event);\n    if (regularListeners) {\n      regularListeners.delete(handler as EventHandler);\n\n      // Clean up empty sets to prevent memory leaks\n      if (regularListeners.size === 0) {\n        this.listeners.delete(event);\n      }\n    }\n\n    const onceSet = this.onceListeners.get(event);\n    if (onceSet) {\n      onceSet.delete(handler as EventHandler);\n\n      // Clean up empty sets\n      if (onceSet.size === 0) {\n        this.onceListeners.delete(event);\n      }\n    }\n  }\n\n  /**\n   * Emit an event to all subscribers\n   * @param event - Event name\n   * @param data - Event payload\n   */\n  emit<T = any>(event: string, data?: T): void {\n    // Call regular listeners\n    const regularListeners = this.listeners.get(event);\n    if (regularListeners) {\n      // Create a copy to avoid issues if listeners modify the set during iteration\n      const listenersCopy = Array.from(regularListeners);\n      listenersCopy.forEach(handler => {\n        try {\n          handler(data);\n        } catch (error) {\n          // Prevent one handler's error from stopping other handlers\n          console.error(`Error in event handler for \"${event}\":`, error);\n        }\n      });\n    }\n\n    // Call once listeners and remove them\n    const onceSet = this.onceListeners.get(event);\n    if (onceSet) {\n      const onceListenersCopy = Array.from(onceSet);\n      // Clear the set before calling handlers to prevent re-entry issues\n      this.onceListeners.delete(event);\n\n      onceListenersCopy.forEach(handler => {\n        try {\n          handler(data);\n        } catch (error) {\n          console.error(`Error in once event handler for \"${event}\":`, error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Remove all listeners for a specific event, or all events if no event specified\n   * @param event - Optional event name. If not provided, removes all listeners.\n   */\n  removeAllListeners(event?: string): void {\n    if (event) {\n      this.listeners.delete(event);\n      this.onceListeners.delete(event);\n    } else {\n      this.listeners.clear();\n      this.onceListeners.clear();\n    }\n  }\n\n  /**\n   * Get the number of listeners for an event\n   * @param event - Event name\n   * @returns Number of listeners\n   */\n  listenerCount(event: string): number {\n    const regularCount = this.listeners.get(event)?.size || 0;\n    const onceCount = this.onceListeners.get(event)?.size || 0;\n    return regularCount + onceCount;\n  }\n\n  /**\n   * Get all event names that have listeners\n   * @returns Array of event names\n   */\n  eventNames(): string[] {\n    const regularEvents = Array.from(this.listeners.keys());\n    const onceEvents = Array.from(this.onceListeners.keys());\n\n    // Combine and deduplicate\n    return Array.from(new Set([...regularEvents, ...onceEvents]));\n  }\n}\n","import { \n    AchievementConfiguration, \n    SimpleAchievementConfig, \n    AchievementConfigurationType,\n    SimpleAchievementDetails,\n    CustomAchievementDetails,\n    AchievementCondition\n} from '../types';\n\n// Type guard to check if config is simple format\nexport function isSimpleConfig(config: AchievementConfigurationType): config is SimpleAchievementConfig {\n    if (!config || typeof config !== 'object') return false;\n    \n    const firstKey = Object.keys(config)[0];\n    if (!firstKey) return true; // Empty config is considered simple\n    \n    const firstValue = config[firstKey];\n    \n    // Check if it's the current complex format (array of AchievementCondition)\n    if (Array.isArray(firstValue)) return false;\n    \n    // Check if it's the simple format (object with string keys)\n    return typeof firstValue === 'object' && !Array.isArray(firstValue);\n}\n\n// Generate a unique ID for achievements\nfunction generateId(): string {\n    return Math.random().toString(36).substr(2, 9);\n}\n\n// Check if achievement details has a custom condition\nfunction hasCustomCondition(details: SimpleAchievementDetails | CustomAchievementDetails): details is CustomAchievementDetails {\n    return 'condition' in details && typeof details.condition === 'function';\n}\n\n// Convert simple config to complex config format\nexport function normalizeAchievements(config: AchievementConfigurationType): AchievementConfiguration {\n    if (!isSimpleConfig(config)) {\n        // Already in complex format, return as-is\n        return config as AchievementConfiguration;\n    }\n    \n    const normalized: AchievementConfiguration = {};\n    \n    Object.entries(config).forEach(([metric, achievements]) => {\n        normalized[metric] = Object.entries(achievements).map(([key, achievement]) => {\n            if (hasCustomCondition(achievement)) {\n                // Custom condition function\n                return {\n                    isConditionMet: (_value, _state) => {\n                        // Convert internal metrics format (arrays) to simple format for custom conditions\n                        const simpleMetrics: Record<string, any> = {};\n                        Object.entries(_state.metrics).forEach(([key, val]) => {\n                            simpleMetrics[key] = Array.isArray(val) ? val[0] : val;\n                        });\n                        return achievement.condition(simpleMetrics);\n                    },\n                    achievementDetails: {\n                        achievementId: `${metric}_custom_${generateId()}`,\n                        achievementTitle: achievement.title,\n                        achievementDescription: achievement.description || '',\n                        achievementIconKey: achievement.icon || 'default'\n                    }\n                };\n            } else {\n                // Threshold-based achievement\n                const threshold = parseFloat(key);\n                const isValidThreshold = !isNaN(threshold);\n                \n                let conditionMet: (value: any) => boolean;\n                \n                if (isValidThreshold) {\n                    // Numeric threshold\n                    conditionMet = (value) => {\n                        const numValue = Array.isArray(value) ? value[0] : value;\n                        return typeof numValue === 'number' && numValue >= threshold;\n                    };\n                } else {\n                    // String or boolean threshold\n                    conditionMet = (value) => {\n                        const actualValue = Array.isArray(value) ? value[0] : value;\n                        \n                        // Handle boolean thresholds\n                        if (key === 'true') return actualValue === true;\n                        if (key === 'false') return actualValue === false;\n                        \n                        // Handle string thresholds\n                        return actualValue === key;\n                    };\n                }\n                \n                return {\n                    isConditionMet: conditionMet,\n                    achievementDetails: {\n                        achievementId: `${metric}_${key}`,\n                        achievementTitle: achievement.title,\n                        achievementDescription: achievement.description || (isValidThreshold ? `Reach ${threshold} ${metric}` : `Achieve ${key} for ${metric}`),\n                        achievementIconKey: achievement.icon || 'default'\n                    }\n                } as AchievementCondition;\n            }\n        });\n    });\n    \n    return normalized;\n}","import { AchievementMetrics } from '../types';\n\n/**\n * Structure of exported achievement data\n */\nexport interface ExportedData {\n  version: string;\n  timestamp: number;\n  metrics: AchievementMetrics;\n  unlockedAchievements: string[];\n  configHash?: string;\n}\n\n/**\n * Exports achievement data to a JSON string\n *\n * @param metrics - Current achievement metrics\n * @param unlocked - Array of unlocked achievement IDs\n * @param configHash - Optional hash of achievement configuration for validation\n * @returns JSON string containing all achievement data\n *\n * @example\n * ```typescript\n * const json = exportAchievementData(_metrics, ['score_100', 'level_5']);\n * // Save json to file or send to server\n * ```\n */\nexport function exportAchievementData(\n  metrics: AchievementMetrics,\n  unlocked: string[],\n  configHash?: string\n): string {\n  const data: ExportedData = {\n    version: '3.3.0',\n    timestamp: Date.now(),\n    metrics,\n    unlockedAchievements: unlocked,\n    ...(configHash && { configHash })\n  };\n\n  return JSON.stringify(data, null, 2);\n}\n\n/**\n * Creates a simple hash of the achievement configuration\n * Used to validate that imported data matches the current configuration\n *\n * @param config - Achievement configuration object\n * @returns Simple hash string\n */\nexport function createConfigHash(config: any): string {\n  // Simple hash based on stringified config\n  // In production, you might want to use a more robust hashing algorithm\n  const str = JSON.stringify(config);\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  return hash.toString(36);\n}\n","import { AchievementMetrics, AchievementMetricValue } from '../types';\nimport { ExportedData } from './dataExport';\n\n/**\n * Options for importing achievement data\n */\nexport interface ImportOptions {\n  /** Strategy for merging imported data with existing data */\n  mergeStrategy?: 'replace' | 'merge' | 'preserve';\n  /** Whether to validate the imported data */\n  validate?: boolean;\n  /** Optional config hash to validate against */\n  expectedConfigHash?: string;\n}\n\n/**\n * Result of an import operation\n */\nexport interface ImportResult {\n  success: boolean;\n  imported: {\n    metrics: number;\n    achievements: number;\n  };\n  errors?: string[];\n  warnings?: string[];\n}\n\n/**\n * Imports achievement data from a JSON string\n *\n * @param jsonString - JSON string containing exported achievement data\n * @param currentMetrics - Current metrics state\n * @param currentUnlocked - Current unlocked achievements\n * @param options - Import options\n * @returns Import result with success status and any errors\n *\n * @example\n * ```typescript\n * const result = importAchievementData(\n *   jsonString,\n *   currentMetrics,\n *   currentUnlocked,\n *   { mergeStrategy: 'merge', validate: true }\n * );\n *\n * if (result.success) {\n *   console.log(`Imported ${result.imported.achievements} achievements`);\n * } else {\n *   console.error('Import failed:', result.errors);\n * }\n * ```\n */\nexport function importAchievementData(\n  jsonString: string,\n  currentMetrics: AchievementMetrics,\n  currentUnlocked: string[],\n  options: ImportOptions = {}\n): ImportResult {\n  const {\n    mergeStrategy = 'replace',\n    validate = true,\n    expectedConfigHash\n  } = options;\n\n  const _errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Parse JSON\n  let data: ExportedData;\n  try {\n    data = JSON.parse(jsonString);\n  } catch {\n    return {\n      success: false,\n      imported: { metrics: 0, achievements: 0 },\n      errors: ['Invalid JSON format']\n    };\n  }\n\n  // Validate structure\n  if (validate) {\n    const validationErrors = validateExportedData(data, expectedConfigHash);\n    if (validationErrors.length > 0) {\n      return {\n        success: false,\n        imported: { metrics: 0, achievements: 0 },\n        errors: validationErrors\n      };\n    }\n  }\n\n  // Version compatibility check\n  if (data.version && data.version !== '3.3.0') {\n    warnings.push(`Data exported from version ${data.version}, current version is 3.3.0`);\n  }\n\n  // Merge metrics based on strategy\n  let mergedMetrics: AchievementMetrics;\n  let mergedUnlocked: string[];\n\n  switch (mergeStrategy) {\n    case 'replace':\n      // Replace all existing data\n      mergedMetrics = data.metrics;\n      mergedUnlocked = data.unlockedAchievements;\n      break;\n\n    case 'merge':\n      // Union of both datasets, keeping higher metric values\n      mergedMetrics = mergeMetrics(currentMetrics, data.metrics);\n      mergedUnlocked = Array.from(new Set([...currentUnlocked, ...data.unlockedAchievements]));\n      break;\n\n    case 'preserve':\n      // Keep existing values, only add new ones\n      mergedMetrics = preserveMetrics(currentMetrics, data.metrics);\n      mergedUnlocked = Array.from(new Set([...currentUnlocked, ...data.unlockedAchievements]));\n      break;\n\n    default:\n      return {\n        success: false,\n        imported: { metrics: 0, achievements: 0 },\n        errors: [`Invalid merge strategy: ${mergeStrategy}`]\n      };\n  }\n\n  return {\n    success: true,\n    imported: {\n      metrics: Object.keys(mergedMetrics).length,\n      achievements: mergedUnlocked.length\n    },\n    ...(warnings.length > 0 && { warnings }),\n    mergedMetrics,\n    mergedUnlocked\n  } as ImportResult & { mergedMetrics: AchievementMetrics; mergedUnlocked: string[] };\n}\n\n/**\n * Validates the structure and content of exported data\n */\nfunction validateExportedData(data: any, expectedConfigHash?: string): string[] {\n  const errors: string[] = [];\n\n  // Check required fields\n  if (!data.version) {\n    errors.push('Missing version field');\n  }\n  if (!data.timestamp) {\n    errors.push('Missing timestamp field');\n  }\n  if (!data.metrics || typeof data.metrics !== 'object') {\n    errors.push('Missing or invalid metrics field');\n  }\n  if (!Array.isArray(data.unlockedAchievements)) {\n    errors.push('Missing or invalid unlockedAchievements field');\n  }\n\n  // Validate config hash if provided\n  if (expectedConfigHash && data.configHash && data.configHash !== expectedConfigHash) {\n    errors.push('Configuration mismatch: imported data may not be compatible with current achievement configuration');\n  }\n\n  // Validate metrics structure\n  if (data.metrics && typeof data.metrics === 'object') {\n    for (const [key, value] of Object.entries(data.metrics)) {\n      if (!Array.isArray(value)) {\n        errors.push(`Invalid metric format for \"${key}\": expected array, got ${typeof value}`);\n      }\n    }\n  }\n\n  // Validate achievement IDs are strings\n  if (Array.isArray(data.unlockedAchievements)) {\n    const invalidIds = data.unlockedAchievements.filter((id: any) => typeof id !== 'string');\n    if (invalidIds.length > 0) {\n      errors.push('All achievement IDs must be strings');\n    }\n  }\n\n  return errors;\n}\n\n/**\n * Merges two metrics objects, keeping higher values for overlapping keys\n */\nfunction mergeMetrics(\n  current: AchievementMetrics,\n  imported: AchievementMetrics\n): AchievementMetrics {\n  const merged: AchievementMetrics = { ...current };\n\n  for (const [key, importedValues] of Object.entries(imported)) {\n    if (!merged[key]) {\n      // New metric, add it\n      merged[key] = importedValues;\n    } else {\n      // Existing metric, merge values\n      merged[key] = mergeMetricValues(merged[key], importedValues);\n    }\n  }\n\n  return merged;\n}\n\n/**\n * Merges two metric value arrays, keeping higher numeric values\n */\nfunction mergeMetricValues(\n  current: AchievementMetricValue[],\n  imported: AchievementMetricValue[]\n): AchievementMetricValue[] {\n  // For simplicity, we'll use the imported values if they're \"higher\"\n  // This works for numeric values; for other types, we prefer imported\n  const currentValue = current[0];\n  const importedValue = imported[0];\n\n  // If both are numbers, keep the higher one\n  if (typeof currentValue === 'number' && typeof importedValue === 'number') {\n    return currentValue >= importedValue ? current : imported;\n  }\n\n  // For non-numeric values, prefer imported (assume it's newer)\n  return imported;\n}\n\n/**\n * Preserves existing metrics, only adding new ones from imported data\n */\nfunction preserveMetrics(\n  current: AchievementMetrics,\n  imported: AchievementMetrics\n): AchievementMetrics {\n  const preserved: AchievementMetrics = { ...current };\n\n  for (const [key, value] of Object.entries(imported)) {\n    if (!preserved[key]) {\n      // Only add if it doesn't exist\n      preserved[key] = value;\n    }\n    // If it exists, keep current value (preserve strategy)\n  }\n\n  return preserved;\n}","/**\n * Type definitions for the achievements engine\n * Framework-agnostic achievement system types\n */\n\nexport type { UnsubscribeFn } from './EventEmitter';\n\n// ============================================================================\n// Core Achievement Types (from react-achievements)\n// ============================================================================\n\nexport type AchievementMetricValue = number | string | boolean | Date | null | undefined;\nexport type AchievementMetricArrayValue = AchievementMetricValue | AchievementMetricValue[];\n\nexport const isDate = (value: any): value is Date => {\n    return value instanceof Date;\n};\n\nexport interface AchievementMetrics {\n    [key: string]: AchievementMetricValue[];\n}\n\nexport interface AchievementDetails {\n    achievementId: string;\n    achievementTitle: string;\n    achievementDescription: string;\n    achievementIconKey?: string;\n}\n\nexport interface AchievementWithStatus extends AchievementDetails {\n    isUnlocked: boolean;\n}\n\nexport interface AchievementCondition {\n    isConditionMet: (value: AchievementMetricArrayValue, state: AchievementState) => boolean;\n    achievementDetails: AchievementDetails | AchievementWithStatus;\n}\n\nexport interface AchievementConfiguration {\n    [key: string]: AchievementCondition[];\n}\n\n// Simple API types\nexport interface SimpleAchievementDetails {\n    title: string;\n    description?: string;\n    icon?: string;\n}\n\nexport interface CustomAchievementDetails extends SimpleAchievementDetails {\n    condition: (metrics: Record<string, any>) => boolean;\n}\n\nexport interface SimpleAchievementConfig {\n    [metric: string]: {\n        [threshold: string]: SimpleAchievementDetails | CustomAchievementDetails;\n    };\n}\n\n// Union type for backward compatibility\nexport type AchievementConfigurationType = AchievementConfiguration | SimpleAchievementConfig;\n\nexport interface InitialAchievementMetrics {\n    [key: string]: AchievementMetricValue;\n}\n\nexport interface AchievementState {\n    metrics: AchievementMetrics;\n    unlockedAchievements: string[];\n}\n\n// ============================================================================\n// Storage Interface Types\n// ============================================================================\n\nexport interface AchievementStorage {\n    getMetrics(): AchievementMetrics;\n    setMetrics(metrics: AchievementMetrics): void;\n    getUnlockedAchievements(): string[];\n    setUnlockedAchievements(achievements: string[]): void;\n    clear(): void;\n}\n\n// Async storage interface - all operations return Promises\nexport interface AsyncAchievementStorage {\n    getMetrics(): Promise<AchievementMetrics>;\n    setMetrics(metrics: AchievementMetrics): Promise<void>;\n    getUnlockedAchievements(): Promise<string[]>;\n    setUnlockedAchievements(achievements: string[]): Promise<void>;\n    clear(): Promise<void>;\n}\n\n// Union type for provider to accept both sync and async storage\nexport type AnyAchievementStorage = AchievementStorage | AsyncAchievementStorage;\n\n// Type guard to detect async storage\nexport function isAsyncStorage(storage: AnyAchievementStorage): storage is AsyncAchievementStorage {\n    // Check if methods return Promises\n    const testResult = (storage as any).getMetrics();\n    return testResult && typeof testResult.then === 'function';\n}\n\nexport enum StorageType {\n    Local = 'local',           // Synchronous localStorage\n    Memory = 'memory',         // Synchronous in-memory storage\n    IndexedDB = 'indexeddb',   // Asynchronous IndexedDB storage\n    RestAPI = 'restapi'        // Asynchronous REST API storage\n}\n\n// ============================================================================\n// Engine-Specific Types\n// ============================================================================\n\n/**\n * Event types emitted by the engine\n */\nexport type EngineEvent =\n    | 'achievement:unlocked'\n    | 'metric:updated'\n    | 'state:changed'\n    | 'error';\n\n/**\n * Event payload when an achievement is unlocked\n */\nexport interface AchievementUnlockedEvent {\n    achievementId: string;\n    achievementTitle: string;\n    achievementDescription: string;\n    achievementIconKey?: string;\n    timestamp: number;\n}\n\n/**\n * Event payload when a metric is updated\n */\nexport interface MetricUpdatedEvent {\n    metric: string;\n    oldValue: any;\n    newValue: any;\n    timestamp: number;\n}\n\n/**\n * Event payload when overall state changes\n */\nexport interface StateChangedEvent {\n    metrics: AchievementMetrics;\n    unlocked: string[];\n    timestamp: number;\n}\n\n/**\n * Event payload when an error occurs\n */\nexport interface ErrorEvent {\n    error: Error;\n    context?: string;\n    timestamp: number;\n}\n\n/**\n * Event handler type\n */\nexport type EventHandler<T = any> = (data: T) => void;\n\n/**\n * Metric updater function for custom event-to-metric mapping\n */\nexport type MetricUpdater = (\n    eventData: any,\n    currentMetrics: Record<string, any>\n) => Record<string, any>;\n\n/**\n * Event mapping configuration\n * Maps event names to either:\n * - String (metric name) for direct 1:1 mapping\n * - MetricUpdater function for custom transformation\n */\nexport interface EventMapping {\n    [eventName: string]: string | MetricUpdater;\n}\n\n/**\n * REST API storage configuration\n */\nexport interface RestApiStorageConfig {\n    baseUrl: string;\n    userId: string;\n    headers?: Record<string, string>;\n    timeout?: number;\n}\n\n/**\n * Configuration for the Achievement Engine\n */\nexport interface EngineConfig {\n    /**\n     * Achievement configuration (Simple or Complex API format)\n     */\n    achievements: AchievementConfigurationType;\n\n    /**\n     * Storage implementation or storage type\n     * Defaults to memory storage\n     */\n    storage?: AchievementStorage | AsyncAchievementStorage | StorageType;\n\n    /**\n     * Optional event-to-metric mapping\n     * Enables event-based tracking with emit()\n     */\n    eventMapping?: EventMapping;\n\n    /**\n     * Error handler for async operations and achievement errors\n     */\n    onError?: (error: Error) => void;\n\n    /**\n     * REST API configuration (required if using StorageType.RestAPI)\n     */\n    restApiConfig?: RestApiStorageConfig;\n}\n\n// ============================================================================\n// Data Export/Import Types\n// ============================================================================\n\nexport interface ImportOptions {\n    merge?: boolean;\n    overwrite?: boolean;\n    validateConfig?: boolean;\n    expectedConfigHash?: string;\n}\n\nexport interface ImportResult {\n    success: boolean;\n    errors?: string[];\n    warnings?: string[];\n    mergedMetrics?: AchievementMetrics;\n    mergedUnlocked?: string[];\n}\n","/**\n * Base error class for all achievement-related errors\n */\nexport class AchievementError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public recoverable: boolean,\n    public remedy?: string\n  ) {\n    super(message);\n    this.name = 'AchievementError';\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AchievementError);\n    }\n  }\n}\n\n/**\n * Error thrown when browser storage quota is exceeded\n */\nexport class StorageQuotaError extends AchievementError {\n  constructor(public bytesNeeded: number) {\n    super(\n      'Browser storage quota exceeded. Achievement data could not be saved.',\n      'STORAGE_QUOTA_EXCEEDED',\n      true,\n      'Clear browser storage, reduce the number of achievements, or use an external database backend. You can export your current data using exportData() before clearing storage.'\n    );\n    this.name = 'StorageQuotaError';\n  }\n}\n\n/**\n * Error thrown when imported data fails validation\n */\nexport class ImportValidationError extends AchievementError {\n  constructor(public validationErrors: string[]) {\n    super(\n      `Imported data failed validation: ${validationErrors.join(', ')}`,\n      'IMPORT_VALIDATION_ERROR',\n      true,\n      'Check that the imported data was exported from a compatible version and matches your current achievement configuration.'\n    );\n    this.name = 'ImportValidationError';\n  }\n}\n\n/**\n * Error thrown when storage operations fail\n */\nexport class StorageError extends AchievementError {\n  constructor(message: string, public originalError?: Error) {\n    super(\n      message,\n      'STORAGE_ERROR',\n      true,\n      'Check browser storage permissions and available space. If using custom storage, verify the implementation is correct.'\n    );\n    this.name = 'StorageError';\n  }\n}\n\n/**\n * Error thrown when configuration is invalid\n */\nexport class ConfigurationError extends AchievementError {\n  constructor(message: string) {\n    super(\n      message,\n      'CONFIGURATION_ERROR',\n      false,\n      'Review your achievement configuration and ensure it follows the correct format.'\n    );\n    this.name = 'ConfigurationError';\n  }\n}\n\n/**\n * Error thrown when network sync operations fail\n */\nexport class SyncError extends AchievementError {\n  public readonly statusCode?: number;\n  public readonly timeout?: number;\n\n  constructor(message: string, details?: { statusCode?: number; timeout?: number }) {\n    super(\n      message,\n      'SYNC_ERROR',\n      true, // recoverable (can retry)\n      'Check your network connection and try again. If the problem persists, achievements will sync when connection is restored.'\n    );\n    this.name = 'SyncError';\n    this.statusCode = details?.statusCode;\n    this.timeout = details?.timeout;\n  }\n}\n\n/**\n * Type guard to check if an error is an AchievementError\n */\nexport function isAchievementError(error: unknown): error is AchievementError {\n  return error instanceof AchievementError;\n}\n\n/**\n * Type guard to check if an error is recoverable\n */\nexport function isRecoverableError(error: unknown): boolean {\n  return isAchievementError(error) && error.recoverable;\n}","import { AchievementStorage, AchievementMetrics, AchievementMetricValue, isDate } from '../types';\nimport { StorageQuotaError, StorageError } from '../errors/AchievementErrors';\n\nexport class LocalStorage implements AchievementStorage {\n    private storageKey: string;\n\n    constructor(storageKey: string) {\n        this.storageKey = storageKey;\n    }\n\n    private serializeValue(value: AchievementMetricValue): any {\n        if (isDate(value)) {\n            return { __type: 'Date', value: value.toISOString() };\n        }\n        return value;\n    }\n\n    private deserializeValue(value: any): AchievementMetricValue {\n        if (value && typeof value === 'object' && value.__type === 'Date') {\n            return new Date(value.value);\n        }\n        return value;\n    }\n\n    private serializeMetrics(metrics: AchievementMetrics): any {\n        const serialized: any = {};\n        for (const [key, values] of Object.entries(metrics)) {\n            serialized[key] = values.map(this.serializeValue);\n        }\n        return serialized;\n    }\n\n    private deserializeMetrics(metrics: any): AchievementMetrics {\n        if (!metrics) return {};\n        const deserialized: AchievementMetrics = {};\n        for (const [key, values] of Object.entries(metrics)) {\n            deserialized[key] = (values as any[]).map(this.deserializeValue);\n        }\n        return deserialized;\n    }\n\n    private getStorageData(): { metrics: AchievementMetrics; unlockedAchievements: string[] } {\n        const data = localStorage.getItem(this.storageKey);\n        if (!data) return { metrics: {}, unlockedAchievements: [] };\n        try {\n            const parsed = JSON.parse(data);\n            return {\n                metrics: this.deserializeMetrics(parsed.metrics || {}),\n                unlockedAchievements: parsed.unlockedAchievements || []\n            };\n        } catch {\n            return { metrics: {}, unlockedAchievements: [] };\n        }\n    }\n\n    private setStorageData(data: { metrics: AchievementMetrics; unlockedAchievements: string[] }): void {\n        try {\n            const serialized = {\n                metrics: this.serializeMetrics(data.metrics),\n                unlockedAchievements: data.unlockedAchievements\n            };\n            const jsonString = JSON.stringify(serialized);\n            localStorage.setItem(this.storageKey, jsonString);\n        } catch (error) {\n            // Throw proper error instead of silently failing\n            if (error instanceof DOMException &&\n                (error.name === 'QuotaExceededError' ||\n                 error.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {\n                const serialized = {\n                    metrics: this.serializeMetrics(data.metrics),\n                    unlockedAchievements: data.unlockedAchievements\n                };\n                const bytesNeeded = JSON.stringify(serialized).length;\n                throw new StorageQuotaError(bytesNeeded);\n            }\n\n            if (error instanceof Error) {\n                if (error.message && error.message.includes('QuotaExceeded')) {\n                    const serialized = {\n                        metrics: this.serializeMetrics(data.metrics),\n                        unlockedAchievements: data.unlockedAchievements\n                    };\n                    const bytesNeeded = JSON.stringify(serialized).length;\n                    throw new StorageQuotaError(bytesNeeded);\n                }\n                throw new StorageError(`Failed to save achievement data: ${error.message}`, error);\n            }\n\n            throw new StorageError('Failed to save achievement data');\n        }\n    }\n\n    getMetrics(): AchievementMetrics {\n        return this.getStorageData().metrics;\n    }\n\n    setMetrics(metrics: AchievementMetrics): void {\n        const data = this.getStorageData();\n        this.setStorageData({ ...data, metrics });\n    }\n\n    getUnlockedAchievements(): string[] {\n        return this.getStorageData().unlockedAchievements;\n    }\n\n    setUnlockedAchievements(achievements: string[]): void {\n        const data = this.getStorageData();\n        this.setStorageData({ ...data, unlockedAchievements: achievements });\n    }\n\n    clear(): void {\n        localStorage.removeItem(this.storageKey);\n    }\n} ","import { AchievementStorage, AchievementMetrics } from '../types';\n\nexport class MemoryStorage implements AchievementStorage {\n  private metrics: AchievementMetrics = {};\n  private unlockedAchievements: string[] = [];\n\n  constructor() {}\n\n  getMetrics(): AchievementMetrics {\n    return this.metrics;\n  }\n\n  setMetrics(metrics: AchievementMetrics): void {\n    this.metrics = metrics;\n  }\n\n  getUnlockedAchievements(): string[] {\n    return this.unlockedAchievements;\n  }\n\n  setUnlockedAchievements(achievements: string[]): void {\n    this.unlockedAchievements = achievements;\n  }\n\n  clear(): void {\n    this.metrics = {};\n    this.unlockedAchievements = [];\n  }\n} ","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nvar ownKeys = function(o) {\r\n    ownKeys = Object.getOwnPropertyNames || function (o) {\r\n        var ar = [];\r\n        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\r\n        return ar;\r\n    };\r\n    return ownKeys(o);\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    var r, s = 0;\r\n    function next() {\r\n        while (r = env.stack.pop()) {\r\n            try {\r\n                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\r\n                if (r.dispose) {\r\n                    var result = r.dispose.call(r.value);\r\n                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n                }\r\n                else s |= 1;\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\r\n    if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\r\n        return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\r\n            return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\r\n        });\r\n    }\r\n    return path;\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __esDecorate: __esDecorate,\r\n    __runInitializers: __runInitializers,\r\n    __propKey: __propKey,\r\n    __setFunctionName: __setFunctionName,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n    __rewriteRelativeImportExtension: __rewriteRelativeImportExtension,\r\n};\r\n","import { AsyncAchievementStorage, AchievementMetrics } from '../types';\nimport { StorageError } from '../errors/AchievementErrors';\n\nexport class IndexedDBStorage implements AsyncAchievementStorage {\n    private dbName: string;\n    private storeName: string = 'achievements';\n    private db: IDBDatabase | null = null;\n    private initPromise: Promise<void>;\n\n    constructor(dbName: string = 'react-achievements') {\n        this.dbName = dbName;\n        this.initPromise = this.initDB();\n    }\n\n    /**\n     * Initialize IndexedDB database and object store\n     */\n    private async initDB(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.dbName, 1);\n\n            request.onerror = () => {\n                reject(new StorageError('Failed to open IndexedDB'));\n            };\n\n            request.onsuccess = () => {\n                this.db = request.result;\n                resolve();\n            };\n\n            request.onupgradeneeded = (event) => {\n                const db = (event.target as IDBOpenDBRequest).result;\n\n                // Create object store if it doesn't exist\n                if (!db.objectStoreNames.contains(this.storeName)) {\n                    db.createObjectStore(this.storeName);\n                }\n            };\n        });\n    }\n\n    /**\n     * Generic get operation from IndexedDB\n     */\n    private async get<T>(key: string): Promise<T | null> {\n        await this.initPromise;\n        if (!this.db) throw new StorageError('Database not initialized');\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction([this.storeName], 'readonly');\n            const store = transaction.objectStore(this.storeName);\n            const request = store.get(key);\n\n            request.onsuccess = () => {\n                resolve(request.result || null);\n            };\n\n            request.onerror = () => {\n                reject(new StorageError(`Failed to read from IndexedDB: ${key}`));\n            };\n        });\n    }\n\n    /**\n     * Generic set operation to IndexedDB\n     */\n    private async set(key: string, value: any): Promise<void> {\n        await this.initPromise;\n        if (!this.db) throw new StorageError('Database not initialized');\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction([this.storeName], 'readwrite');\n            const store = transaction.objectStore(this.storeName);\n            const request = store.put(value, key);\n\n            request.onsuccess = () => {\n                resolve();\n            };\n\n            request.onerror = () => {\n                reject(new StorageError(`Failed to write to IndexedDB: ${key}`));\n            };\n        });\n    }\n\n    /**\n     * Delete operation from IndexedDB\n     */\n    private async delete(key: string): Promise<void> {\n        await this.initPromise;\n        if (!this.db) throw new StorageError('Database not initialized');\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction([this.storeName], 'readwrite');\n            const store = transaction.objectStore(this.storeName);\n            const request = store.delete(key);\n\n            request.onsuccess = () => {\n                resolve();\n            };\n\n            request.onerror = () => {\n                reject(new StorageError(`Failed to delete from IndexedDB: ${key}`));\n            };\n        });\n    }\n\n    async getMetrics(): Promise<AchievementMetrics> {\n        const metrics = await this.get<AchievementMetrics>('metrics');\n        return metrics || {};\n    }\n\n    async setMetrics(metrics: AchievementMetrics): Promise<void> {\n        await this.set('metrics', metrics);\n    }\n\n    async getUnlockedAchievements(): Promise<string[]> {\n        const unlocked = await this.get<string[]>('unlocked');\n        return unlocked || [];\n    }\n\n    async setUnlockedAchievements(achievements: string[]): Promise<void> {\n        await this.set('unlocked', achievements);\n    }\n\n    async clear(): Promise<void> {\n        await Promise.all([\n            this.delete('metrics'),\n            this.delete('unlocked')\n        ]);\n    }\n}\n","import { AsyncAchievementStorage, AchievementMetrics } from '../types';\nimport { StorageError, SyncError, AchievementError } from '../errors/AchievementErrors';\n\nexport interface RestApiStorageConfig {\n    baseUrl: string;              // e.g., 'https://api.example.com'\n    userId: string;               // User identifier\n    headers?: Record<string, string>; // Custom headers (auth tokens, etc.)\n    timeout?: number;             // Request timeout in ms (default: 10000)\n}\n\nexport class RestApiStorage implements AsyncAchievementStorage {\n    private config: Required<RestApiStorageConfig>;\n\n    constructor(config: RestApiStorageConfig) {\n        this.config = {\n            timeout: 10000,\n            headers: {},\n            ...config\n        };\n    }\n\n    /**\n     * Generic fetch wrapper with timeout and error handling\n     */\n    private async fetchWithTimeout(url: string, options: RequestInit): Promise<Response> {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);\n\n        try {\n            const response = await fetch(url, {\n                ...options,\n                headers: {\n                    'Content-Type': 'application/json',\n                    ...this.config.headers,\n                    ...options.headers\n                },\n                signal: controller.signal\n            });\n\n            clearTimeout(timeoutId);\n\n            if (!response.ok) {\n                throw new SyncError(\n                    `HTTP ${response.status}: ${response.statusText}`,\n                    { statusCode: response.status }\n                );\n            }\n\n            return response;\n        } catch (error) {\n            clearTimeout(timeoutId);\n\n            if (error instanceof Error && error.name === 'AbortError') {\n                throw new SyncError('Request timeout', { timeout: this.config.timeout });\n            }\n\n            throw error;\n        }\n    }\n\n    async getMetrics(): Promise<AchievementMetrics> {\n        try {\n            const url = `${this.config.baseUrl}/users/${this.config.userId}/achievements/metrics`;\n            const response = await this.fetchWithTimeout(url, { method: 'GET' });\n            const data = await response.json();\n            return data.metrics || {};\n        } catch (error) {\n            // Re-throw SyncError and other AchievementErrors (but not StorageError)\n            // Multiple checks for Jest compatibility\n            const err = error as any;\n            if (err?.constructor?.name === 'SyncError' || err?.name === 'SyncError') {\n                throw error;\n            }\n            // Also check instanceof for normal cases\n            if (error instanceof AchievementError && !(error instanceof StorageError)) {\n                throw error;\n            }\n            throw new StorageError('Failed to fetch metrics from API', error as Error);\n        }\n    }\n\n    async setMetrics(metrics: AchievementMetrics): Promise<void> {\n        try {\n            const url = `${this.config.baseUrl}/users/${this.config.userId}/achievements/metrics`;\n            await this.fetchWithTimeout(url, {\n                method: 'PUT',\n                body: JSON.stringify({ metrics })\n            });\n        } catch (error) {\n            const err = error as any;\n            if (err?.constructor?.name === 'SyncError' || err?.name === 'SyncError') throw error;\n            if (error instanceof AchievementError && !(error instanceof StorageError)) throw error;\n            throw new StorageError('Failed to save metrics to API', error as Error);\n        }\n    }\n\n    async getUnlockedAchievements(): Promise<string[]> {\n        try {\n            const url = `${this.config.baseUrl}/users/${this.config.userId}/achievements/unlocked`;\n            const response = await this.fetchWithTimeout(url, { method: 'GET' });\n            const data = await response.json();\n            return data.unlocked || [];\n        } catch (error) {\n            const err = error as any;\n            if (err?.constructor?.name === 'SyncError' || err?.name === 'SyncError') throw error;\n            if (error instanceof AchievementError && !(error instanceof StorageError)) throw error;\n            throw new StorageError('Failed to fetch unlocked achievements from API', error as Error);\n        }\n    }\n\n    async setUnlockedAchievements(achievements: string[]): Promise<void> {\n        try {\n            const url = `${this.config.baseUrl}/users/${this.config.userId}/achievements/unlocked`;\n            await this.fetchWithTimeout(url, {\n                method: 'PUT',\n                body: JSON.stringify({ unlocked: achievements })\n            });\n        } catch (error) {\n            const err = error as any;\n            if (err?.constructor?.name === 'SyncError' || err?.name === 'SyncError') throw error;\n            if (error instanceof AchievementError && !(error instanceof StorageError)) throw error;\n            throw new StorageError('Failed to save unlocked achievements to API', error as Error);\n        }\n    }\n\n    async clear(): Promise<void> {\n        try {\n            const url = `${this.config.baseUrl}/users/${this.config.userId}/achievements`;\n            await this.fetchWithTimeout(url, { method: 'DELETE' });\n        } catch (error) {\n            const err = error as any;\n            if (err?.constructor?.name === 'SyncError' || err?.name === 'SyncError') throw error;\n            if (error instanceof AchievementError && !(error instanceof StorageError)) throw error;\n            throw new StorageError('Failed to clear achievements via API', error as Error);\n        }\n    }\n}\n","import { AchievementStorage, AsyncAchievementStorage, AchievementMetrics } from '../types';\nimport { StorageError, AchievementError } from '../errors/AchievementErrors';\n\nexport class AsyncStorageAdapter implements AchievementStorage {\n    private asyncStorage: AsyncAchievementStorage;\n    private cache: {\n        metrics: AchievementMetrics;\n        unlocked: string[];\n        loaded: boolean;\n    };\n    private pendingWrites: Promise<void>[] = [];\n    private onError?: (error: AchievementError) => void;\n\n    constructor(\n        asyncStorage: AsyncAchievementStorage,\n        options?: { onError?: (error: AchievementError) => void }\n    ) {\n        this.asyncStorage = asyncStorage;\n        this.onError = options?.onError;\n        this.cache = {\n            metrics: {},\n            unlocked: [],\n            loaded: false\n        };\n\n        // Eagerly load data from async storage (non-blocking)\n        this.initializeCache();\n    }\n\n    /**\n     * Initialize cache by loading from async storage\n     * This happens in the background during construction\n     */\n    private async initializeCache(): Promise<void> {\n        try {\n            const [metrics, unlocked] = await Promise.all([\n                this.asyncStorage.getMetrics(),\n                this.asyncStorage.getUnlockedAchievements()\n            ]);\n\n            this.cache.metrics = metrics;\n            this.cache.unlocked = unlocked;\n            this.cache.loaded = true;\n        } catch (error) {\n            // Handle initialization errors\n            console.error('Failed to initialize async storage:', error);\n            if (this.onError) {\n                const storageError = error instanceof AchievementError\n                    ? error\n                    : new StorageError('Failed to initialize storage', error as Error);\n                this.onError(storageError);\n            }\n            // Set to empty state on error\n            this.cache.loaded = true; // Mark as loaded even on error to prevent blocking\n        }\n    }\n\n    /**\n     * Wait for cache to be loaded (used internally)\n     * Returns immediately if already loaded, otherwise waits\n     */\n    private async ensureCacheLoaded(): Promise<void> {\n        while (!this.cache.loaded) {\n            await new Promise(resolve => setTimeout(resolve, 10));\n        }\n    }\n\n    /**\n     * SYNC READ: Returns cached metrics immediately\n     * Cache is loaded eagerly during construction\n     */\n    getMetrics(): AchievementMetrics {\n        return this.cache.metrics;\n    }\n\n    /**\n     * SYNC WRITE: Updates cache immediately, writes to storage in background\n     * Uses optimistic updates - assumes write will succeed\n     */\n    setMetrics(metrics: AchievementMetrics): void {\n        // Update cache immediately (optimistic update)\n        this.cache.metrics = metrics;\n\n        // Write to async storage in background\n        const writePromise = this.asyncStorage.setMetrics(metrics).catch(error => {\n            console.error('Failed to write metrics to async storage:', error);\n            if (this.onError) {\n                const storageError = error instanceof AchievementError\n                    ? error\n                    : new StorageError('Failed to write metrics', error as Error);\n                this.onError(storageError);\n            }\n        });\n\n        // Track pending write for cleanup/testing\n        this.pendingWrites.push(writePromise);\n    }\n\n    /**\n     * SYNC READ: Returns cached unlocked achievements immediately\n     */\n    getUnlockedAchievements(): string[] {\n        return this.cache.unlocked;\n    }\n\n    /**\n     * SYNC WRITE: Updates cache immediately, writes to storage in background\n     */\n    setUnlockedAchievements(achievements: string[]): void {\n        // Update cache immediately (optimistic update)\n        this.cache.unlocked = achievements;\n\n        // Write to async storage in background\n        const writePromise = this.asyncStorage.setUnlockedAchievements(achievements).catch(error => {\n            console.error('Failed to write unlocked achievements to async storage:', error);\n            if (this.onError) {\n                const storageError = error instanceof AchievementError\n                    ? error\n                    : new StorageError('Failed to write achievements', error as Error);\n                this.onError(storageError);\n            }\n        });\n\n        // Track pending write\n        this.pendingWrites.push(writePromise);\n    }\n\n    /**\n     * SYNC CLEAR: Clears cache immediately, clears storage in background\n     */\n    clear(): void {\n        // Clear cache immediately\n        this.cache.metrics = {};\n        this.cache.unlocked = [];\n\n        // Clear async storage in background\n        const clearPromise = this.asyncStorage.clear().catch(error => {\n            console.error('Failed to clear async storage:', error);\n            if (this.onError) {\n                const storageError = error instanceof AchievementError\n                    ? error\n                    : new StorageError('Failed to clear storage', error as Error);\n                this.onError(storageError);\n            }\n        });\n\n        // Track pending write\n        this.pendingWrites.push(clearPromise);\n    }\n\n    /**\n     * Wait for all pending writes to complete (useful for testing/cleanup)\n     * NOT part of AchievementStorage interface - utility method\n     */\n    async flush(): Promise<void> {\n        await Promise.all(this.pendingWrites);\n        this.pendingWrites = [];\n    }\n}\n","/**\n * AchievementEngine - Framework-agnostic achievement system\n * Event-based core with support for multiple storage backends\n */\n\nimport { EventEmitter, UnsubscribeFn } from './EventEmitter';\nimport { normalizeAchievements } from './utils/configNormalizer';\nimport { exportAchievementData, createConfigHash } from './utils/dataExport';\nimport { importAchievementData } from './utils/dataImport';\nimport { LocalStorage } from './storage/LocalStorage';\nimport { MemoryStorage } from './storage/MemoryStorage';\nimport { IndexedDBStorage } from './storage/IndexedDBStorage';\nimport { RestApiStorage } from './storage/RestApiStorage';\nimport { AsyncStorageAdapter } from './storage/AsyncStorageAdapter';\nimport type {\n    EngineConfig,\n    EngineEvent,\n    AchievementMetrics,\n    AchievementWithStatus,\n    AchievementStorage,\n    AsyncAchievementStorage,\n    StorageType,\n    ImportOptions,\n    ImportResult,\n    AchievementConfiguration,\n    AchievementUnlockedEvent,\n    MetricUpdatedEvent,\n    StateChangedEvent,\n    ErrorEvent,\n    EventMapping,\n    MetricUpdater,\n    isAsyncStorage,\n    AchievementConfigurationType\n} from './types';\n\nexport class AchievementEngine extends EventEmitter {\n    private config: EngineConfig;\n    private achievements: AchievementConfiguration;\n    private storage: AchievementStorage;\n    private metrics: Record<string, any> = {};\n    private unlockedAchievements: string[] = [];\n    private configHash: string;\n\n    constructor(config: EngineConfig) {\n        super();\n        this.config = config;\n\n        // Normalize achievements configuration\n        this.achievements = normalizeAchievements(config.achievements);\n\n        // Create config hash for export/import validation\n        this.configHash = createConfigHash(config.achievements);\n\n        // Initialize storage\n        this.storage = this.initializeStorage(config);\n\n        // Load initial state from storage\n        this.loadFromStorage();\n    }\n\n    /**\n     * Initialize storage based on configuration\n     */\n    private initializeStorage(config: EngineConfig): AchievementStorage {\n        const { storage, onError, restApiConfig } = config;\n\n        // If no storage specified, use memory storage\n        if (!storage) {\n            return new MemoryStorage();\n        }\n\n        // Handle string storage types\n        if (typeof storage === 'string') {\n            switch (storage) {\n                case 'local':\n                    return new LocalStorage('achievements');\n                case 'memory':\n                    return new MemoryStorage();\n                case 'indexeddb': {\n                    const indexedDB = new IndexedDBStorage('achievements-engine');\n                    return new AsyncStorageAdapter(indexedDB, { onError });\n                }\n                case 'restapi': {\n                    if (!restApiConfig) {\n                        throw new Error('restApiConfig is required when using StorageType.RestAPI');\n                    }\n                    const restApi = new RestApiStorage(restApiConfig);\n                    return new AsyncStorageAdapter(restApi, { onError });\n                }\n                default:\n                    throw new Error(`Unsupported storage type: ${storage}`);\n            }\n        }\n\n        // Handle custom storage instances\n        const storageInstance = storage as any;\n        if (typeof storageInstance.getMetrics === 'function') {\n            // Check if async storage\n            const testResult = storageInstance.getMetrics();\n            if (testResult && typeof testResult.then === 'function') {\n                return new AsyncStorageAdapter(storageInstance as AsyncAchievementStorage, { onError });\n            }\n            return storageInstance as AchievementStorage;\n        }\n\n        throw new Error('Invalid storage configuration');\n    }\n\n    /**\n     * Load state from storage\n     */\n    private loadFromStorage(): void {\n        try {\n            const savedMetrics = this.storage.getMetrics() || {};\n            const savedUnlocked = this.storage.getUnlockedAchievements() || [];\n\n            // Convert metrics from array format to simple format\n            Object.entries(savedMetrics).forEach(([key, value]) => {\n                this.metrics[key] = Array.isArray(value) ? value[0] : value;\n            });\n\n            this.unlockedAchievements = savedUnlocked;\n        } catch (error) {\n            this.handleError(error as Error, 'loadFromStorage');\n        }\n    }\n\n    /**\n     * Save state to storage\n     */\n    private saveToStorage(): void {\n        try {\n            // Convert metrics to array format for storage\n            const metricsForStorage: AchievementMetrics = {};\n            Object.entries(this.metrics).forEach(([key, value]) => {\n                metricsForStorage[key] = Array.isArray(value) ? value : [value];\n            });\n\n            this.storage.setMetrics(metricsForStorage);\n            this.storage.setUnlockedAchievements(this.unlockedAchievements);\n        } catch (error) {\n            this.handleError(error as Error, 'saveToStorage');\n        }\n    }\n\n    /**\n     * Handle errors with optional callback\n     */\n    private handleError(error: Error, context?: string): void {\n        const errorEvent: ErrorEvent = {\n            error,\n            context,\n            timestamp: Date.now()\n        };\n\n        // Emit error event\n        this.emit<ErrorEvent>('error', errorEvent);\n\n        // Call config error handler if provided\n        if (this.config.onError) {\n            this.config.onError(error);\n        }\n    }\n\n    /**\n     * Emit a custom event and optionally update metrics based on event mapping\n     * @param eventName - Name of the event\n     * @param data - Event data\n     */\n    emit<T = any>(eventName: string, data?: T): void {\n        // If this is a mapped event, update metrics\n        if (this.config.eventMapping && eventName in this.config.eventMapping) {\n            const mapping = this.config.eventMapping[eventName];\n\n            if (typeof mapping === 'string') {\n                // Direct mapping: event name -> metric name\n                this.update({ [mapping]: data });\n            } else if (typeof mapping === 'function') {\n                // Custom transformer function\n                const metricsUpdate = mapping(data, { ...this.metrics });\n                this.update(metricsUpdate);\n            }\n        }\n\n        // Emit the event to listeners\n        super.emit(eventName, data);\n    }\n\n    /**\n     * Update metrics and evaluate achievements\n     * @param newMetrics - Metrics to update\n     */\n    update(newMetrics: Record<string, any>): void {\n        const oldMetrics = { ...this.metrics };\n\n        // Update metrics\n        Object.entries(newMetrics).forEach(([key, value]) => {\n            const oldValue = this.metrics[key];\n            this.metrics[key] = value;\n\n            // Emit metric updated event\n            if (oldValue !== value) {\n                const metricEvent: MetricUpdatedEvent = {\n                    metric: key,\n                    oldValue,\n                    newValue: value,\n                    timestamp: Date.now()\n                };\n                super.emit<MetricUpdatedEvent>('metric:updated', metricEvent);\n            }\n        });\n\n        // Evaluate achievements\n        this.evaluateAchievements();\n\n        // Save to storage\n        this.saveToStorage();\n\n        // Emit state changed event\n        const stateEvent: StateChangedEvent = {\n            metrics: this.getMetricsAsArray(),\n            unlocked: [...this.unlockedAchievements],\n            timestamp: Date.now()\n        };\n        super.emit<StateChangedEvent>('state:changed', stateEvent);\n    }\n\n    /**\n     * Evaluate all achievements and unlock any newly met conditions\n     * This is the core evaluation logic extracted from AchievementProvider\n     */\n    private evaluateAchievements(): void {\n        const newlyUnlockedAchievements: string[] = [];\n\n        // Convert metrics to array format for condition checking\n        const metricsInArrayFormat = this.getMetricsAsArray();\n\n        // Iterate through all achievements\n        Object.entries(this.achievements).forEach(([metricName, metricAchievements]) => {\n            metricAchievements.forEach((achievement) => {\n                const state = {\n                    metrics: metricsInArrayFormat,\n                    unlockedAchievements: this.unlockedAchievements\n                };\n\n                const achievementId = achievement.achievementDetails.achievementId;\n\n                // Check if already unlocked\n                if (this.unlockedAchievements.includes(achievementId)) {\n                    return;\n                }\n\n                // Get current value for this metric\n                const currentValue = this.metrics[metricName];\n\n                // For custom conditions, we always check against all metrics\n                // For threshold-based conditions, we check against the specific metric\n                const shouldCheckAchievement = currentValue !== undefined ||\n                    achievementId.includes('_custom_');\n\n                if (shouldCheckAchievement) {\n                    const valueToCheck = currentValue;\n\n                    if (achievement.isConditionMet(valueToCheck, state)) {\n                        newlyUnlockedAchievements.push(achievementId);\n\n                        // Emit achievement unlocked event\n                        const unlockEvent: AchievementUnlockedEvent = {\n                            achievementId,\n                            achievementTitle: achievement.achievementDetails.achievementTitle || 'Achievement Unlocked!',\n                            achievementDescription: achievement.achievementDetails.achievementDescription || '',\n                            achievementIconKey: achievement.achievementDetails.achievementIconKey,\n                            timestamp: Date.now()\n                        };\n                        super.emit<AchievementUnlockedEvent>('achievement:unlocked', unlockEvent);\n                    }\n                }\n            });\n        });\n\n        // Add newly unlocked achievements to the list\n        if (newlyUnlockedAchievements.length > 0) {\n            this.unlockedAchievements = [...this.unlockedAchievements, ...newlyUnlockedAchievements];\n        }\n    }\n\n    /**\n     * Get metrics in array format (for backward compatibility with storage)\n     */\n    private getMetricsAsArray(): AchievementMetrics {\n        const metricsInArrayFormat: AchievementMetrics = {};\n        Object.entries(this.metrics).forEach(([key, value]) => {\n            metricsInArrayFormat[key] = Array.isArray(value) ? value : [value];\n        });\n        return metricsInArrayFormat;\n    }\n\n    /**\n     * Get current metrics (readonly to prevent external modification)\n     */\n    getMetrics(): Readonly<Record<string, any>> {\n        return Object.freeze({ ...this.metrics });\n    }\n\n    /**\n     * Get unlocked achievement IDs (readonly)\n     */\n    getUnlocked(): readonly string[] {\n        return Object.freeze([...this.unlockedAchievements]);\n    }\n\n    /**\n     * Get all achievements with their unlock status\n     */\n    getAllAchievements(): AchievementWithStatus[] {\n        const result: AchievementWithStatus[] = [];\n\n        Object.entries(this.achievements).forEach(([_metricName, metricAchievements]) => {\n            metricAchievements.forEach((achievement) => {\n                const { achievementDetails } = achievement;\n                const isUnlocked = this.unlockedAchievements.includes(achievementDetails.achievementId);\n\n                result.push({\n                    achievementId: achievementDetails.achievementId,\n                    achievementTitle: achievementDetails.achievementTitle || '',\n                    achievementDescription: achievementDetails.achievementDescription || '',\n                    achievementIconKey: achievementDetails.achievementIconKey,\n                    isUnlocked\n                });\n            });\n        });\n\n        return result;\n    }\n\n    /**\n     * Reset all achievement data\n     */\n    reset(): void {\n        this.metrics = {};\n        this.unlockedAchievements = [];\n\n        try {\n            this.storage.clear();\n        } catch (error) {\n            this.handleError(error as Error, 'reset');\n        }\n\n        // Emit state changed event\n        const stateEvent: StateChangedEvent = {\n            metrics: {},\n            unlocked: [],\n            timestamp: Date.now()\n        };\n        super.emit<StateChangedEvent>('state:changed', stateEvent);\n    }\n\n    /**\n     * Clean up resources and event listeners\n     */\n    destroy(): void {\n        this.removeAllListeners();\n    }\n\n    /**\n     * Export achievement data as JSON string\n     */\n    export(): string {\n        const metricsInArrayFormat = this.getMetricsAsArray();\n        return exportAchievementData(metricsInArrayFormat, this.unlockedAchievements, this.configHash);\n    }\n\n    /**\n     * Import achievement data from JSON string\n     * @param jsonString - Exported achievement data\n     * @param options - Import options\n     */\n    import(jsonString: string, options?: ImportOptions): ImportResult {\n        const metricsInArrayFormat = this.getMetricsAsArray();\n\n        const result = importAchievementData(\n            jsonString,\n            metricsInArrayFormat,\n            this.unlockedAchievements,\n            { ...options, expectedConfigHash: this.configHash }\n        );\n\n        if (result.success && 'mergedMetrics' in result && 'mergedUnlocked' in result) {\n            // Convert metrics from array format to simple format\n            const mergedMetrics: Record<string, any> = {};\n            Object.entries(result.mergedMetrics!).forEach(([key, value]) => {\n                mergedMetrics[key] = Array.isArray(value) ? value[0] : value;\n            });\n\n            this.metrics = mergedMetrics;\n            this.unlockedAchievements = (result.mergedUnlocked as string[]) || [];\n\n            // Save to storage\n            this.saveToStorage();\n\n            // Emit state changed event\n            const stateEvent: StateChangedEvent = {\n                metrics: this.getMetricsAsArray(),\n                unlocked: [...this.unlockedAchievements],\n                timestamp: Date.now()\n            };\n            super.emit<StateChangedEvent>('state:changed', stateEvent);\n        }\n\n        return result;\n    }\n\n    /**\n     * Subscribe to engine events\n     * @param event - Event name\n     * @param handler - Event handler\n     */\n    on(event: EngineEvent, handler: (data: any) => void): UnsubscribeFn {\n        return super.on(event, handler);\n    }\n\n    /**\n     * Subscribe to an event once\n     * @param event - Event name\n     * @param handler - Event handler\n     */\n    once(event: EngineEvent, handler: (data: any) => void): UnsubscribeFn {\n        return super.once(event, handler);\n    }\n\n    /**\n     * Unsubscribe from an event\n     * @param event - Event name\n     * @param handler - Event handler\n     */\n    off(event: EngineEvent, handler: (data: any) => void): void {\n        return super.off(event, handler);\n    }\n}\n","import { AsyncAchievementStorage, AchievementMetrics } from '../types';\nimport { StorageError } from '../errors/AchievementErrors';\n\ninterface QueuedOperation {\n    id: string;\n    type: 'setMetrics' | 'setUnlockedAchievements' | 'clear';\n    data?: any;\n    timestamp: number;\n}\n\nexport class OfflineQueueStorage implements AsyncAchievementStorage {\n    private innerStorage: AsyncAchievementStorage;\n    private queue: QueuedOperation[] = [];\n    private isOnline: boolean = typeof navigator !== 'undefined' ? navigator.onLine : true;\n    private isSyncing: boolean = false;\n    private queueStorageKey: string = 'achievements_offline_queue';\n\n    constructor(innerStorage: AsyncAchievementStorage) {\n        this.innerStorage = innerStorage;\n\n        // Load queued operations from localStorage\n        this.loadQueue();\n\n        // Listen for online/offline events (only in browser environment)\n        if (typeof window !== 'undefined') {\n            window.addEventListener('online', this.handleOnline);\n            window.addEventListener('offline', this.handleOffline);\n        }\n\n        // Process queue if already online\n        if (this.isOnline) {\n            this.processQueue();\n        }\n    }\n\n    private loadQueue(): void {\n        try {\n            if (typeof localStorage !== 'undefined') {\n                const queueData = localStorage.getItem(this.queueStorageKey);\n                if (queueData) {\n                    this.queue = JSON.parse(queueData);\n                }\n            }\n        } catch (error) {\n            console.error('Failed to load offline queue:', error);\n            this.queue = [];\n        }\n    }\n\n    private saveQueue(): void {\n        try {\n            if (typeof localStorage !== 'undefined') {\n                localStorage.setItem(this.queueStorageKey, JSON.stringify(this.queue));\n            }\n        } catch (error) {\n            console.error('Failed to save offline queue:', error);\n        }\n    }\n\n    private handleOnline = (): void => {\n        this.isOnline = true;\n        console.log('[OfflineQueue] Back online, processing queue...');\n        this.processQueue();\n    };\n\n    private handleOffline = (): void => {\n        this.isOnline = false;\n        console.log('[OfflineQueue] Offline mode activated');\n    };\n\n    private async processQueue(): Promise<void> {\n        if (this.isSyncing || this.queue.length === 0 || !this.isOnline) {\n            return;\n        }\n\n        this.isSyncing = true;\n\n        try {\n            // Process operations in order\n            while (this.queue.length > 0 && this.isOnline) {\n                const operation = this.queue[0];\n\n                try {\n                    switch (operation.type) {\n                        case 'setMetrics':\n                            await this.innerStorage.setMetrics(operation.data);\n                            break;\n                        case 'setUnlockedAchievements':\n                            await this.innerStorage.setUnlockedAchievements(operation.data);\n                            break;\n                        case 'clear':\n                            await this.innerStorage.clear();\n                            break;\n                    }\n\n                    // Operation succeeded, remove from queue\n                    this.queue.shift();\n                    this.saveQueue();\n                } catch (error) {\n                    console.error('Failed to sync queued operation:', error);\n                    // Stop processing on error, will retry later\n                    break;\n                }\n            }\n        } finally {\n            this.isSyncing = false;\n        }\n    }\n\n    private queueOperation(type: QueuedOperation['type'], data?: any): void {\n        const operation: QueuedOperation = {\n            id: `${Date.now()}_${Math.random()}`,\n            type,\n            data,\n            timestamp: Date.now()\n        };\n\n        this.queue.push(operation);\n        this.saveQueue();\n\n        // Try to process queue if online\n        if (this.isOnline) {\n            this.processQueue();\n        }\n    }\n\n    async getMetrics(): Promise<AchievementMetrics> {\n        // Reads always try to hit the server first\n        try {\n            return await this.innerStorage.getMetrics();\n        } catch (error) {\n            if (!this.isOnline) {\n                throw new StorageError('Cannot read metrics while offline');\n            }\n            throw error;\n        }\n    }\n\n    async setMetrics(metrics: AchievementMetrics): Promise<void> {\n        if (this.isOnline) {\n            try {\n                await this.innerStorage.setMetrics(metrics);\n                return;\n            } catch (error) {\n                // Failed while online, queue it\n                console.warn('Failed to set metrics, queuing for later:', error);\n            }\n        }\n\n        // Queue operation if offline or if online operation failed\n        this.queueOperation('setMetrics', metrics);\n    }\n\n    async getUnlockedAchievements(): Promise<string[]> {\n        // Reads always try to hit the server first\n        try {\n            return await this.innerStorage.getUnlockedAchievements();\n        } catch (error) {\n            if (!this.isOnline) {\n                throw new StorageError('Cannot read achievements while offline');\n            }\n            throw error;\n        }\n    }\n\n    async setUnlockedAchievements(achievements: string[]): Promise<void> {\n        if (this.isOnline) {\n            try {\n                await this.innerStorage.setUnlockedAchievements(achievements);\n                return;\n            } catch (error) {\n                // Failed while online, queue it\n                console.warn('Failed to set unlocked achievements, queuing for later:', error);\n            }\n        }\n\n        // Queue operation if offline or if online operation failed\n        this.queueOperation('setUnlockedAchievements', achievements);\n    }\n\n    async clear(): Promise<void> {\n        if (this.isOnline) {\n            try {\n                await this.innerStorage.clear();\n                // Also clear the queue\n                this.queue = [];\n                this.saveQueue();\n                return;\n            } catch (error) {\n                console.warn('Failed to clear, queuing for later:', error);\n            }\n        }\n\n        // Queue operation if offline or if online operation failed\n        this.queueOperation('clear');\n    }\n\n    /**\n     * Manually trigger queue processing (useful for testing)\n     */\n    async sync(): Promise<void> {\n        await this.processQueue();\n    }\n\n    /**\n     * Get current queue status (useful for debugging)\n     */\n    getQueueStatus(): { pending: number; operations: QueuedOperation[] } {\n        return {\n            pending: this.queue.length,\n            operations: [...this.queue]\n        };\n    }\n\n    /**\n     * Cleanup listeners (call on unmount)\n     */\n    destroy(): void {\n        if (typeof window !== 'undefined') {\n            window.removeEventListener('online', this.handleOnline);\n            window.removeEventListener('offline', this.handleOffline);\n        }\n    }\n}\n"],"names":[],"mappings":"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","x_google_ignoreList":[8]}